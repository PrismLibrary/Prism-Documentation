"use strict";(globalThis.webpackChunkprism_docs=globalThis.webpackChunkprism_docs||[]).push([[8424],{2858:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/nuget-install-613abb0cfbed901157e82adc2b9b9be2.png"},3124:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/FirstRun-acec051872dd47a03dd046f93a304237.PNG"},3299:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/ProjectStructure-39b189acf55630910ebbd56b572c1ed1.PNG"},3997:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/viewmodellocator-25c1cacf65b747825bc9bb06ef953cc4.png"},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(6540);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}},9899:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"platforms/wpf/getting-started","title":"Getting Started","description":"Getting started with Prism is pretty easy. Follow the steps below and you will be up and running quickly with the start of a modular and easy to maintain app.","source":"@site/versioned_docs/version-9.0/platforms/wpf/getting-started.md","sourceDirName":"platforms/wpf","slug":"/platforms/wpf/getting-started","permalink":"/docs/9.0/platforms/wpf/getting-started","draft":false,"unlisted":false,"editUrl":"https://github.com/PrismLibrary/Prism-Documentation/edit/master/versioned_docs/version-9.0/platforms/wpf/getting-started.md","tags":[],"version":"9.0","lastUpdatedBy":"Dan Siegel","lastUpdatedAt":1763924367000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Dialog Service","permalink":"/docs/9.0/platforms/wpf/dialog-service"},"next":{"title":"Composing the User Interface Using the Prism Library for WPF","permalink":"/docs/9.0/platforms/wpf/view-composition"}}');var s=n(4848),o=n(8453);const r={sidebar_position:1},a="Getting Started",d={},l=[{value:"Install the Nuget Packages",id:"install-the-nuget-packages",level:2},{value:"Override the Existing Application Object",id:"override-the-existing-application-object",level:2},{value:"RegisterTypes",id:"registertypes",level:3},{value:"CreateShell",id:"createshell",level:3},{value:"View Models",id:"view-models",level:2},{value:"Creating the View Model",id:"creating-the-view-model",level:2},{value:"Using the ViewModelLocator",id:"using-the-viewmodellocator",level:3}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"getting-started",children:"Getting Started"})}),"\n",(0,s.jsx)(t.p,{children:"Getting started with Prism is pretty easy. Follow the steps below and you will be up and running quickly with the start of a modular and easy to maintain app."}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"This guide assumes that you have some knowledge of the structure of a WPF application project and some comfort with C#. An understanding of the Model-View-ViewModel (MVVM) pattern is helpful as well as WPF lends to that pattern very easily. If you aren't, consider taking a moment to do a bit of research on it first."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"install-the-nuget-packages",children:"Install the Nuget Packages"}),"\n",(0,s.jsx)(t.p,{children:"Create a brand new WPF application in Visual Studio. Next up is to install the appropriate nuget packages. At this point, a choice needs to be made, and that is which container to use for managing dependencies. For the purposes of this documentation, Unity will be the container of choice. See the list below of what is available."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Package"}),(0,s.jsx)(t.th,{children:"Container"}),(0,s.jsx)(t.th,{children:"Version"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Prism.Unity"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.a,{href:"https://github.com/unitycontainer/unity",children:"Unity"})}),(0,s.jsx)(t.td,{children:"5.11.1"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Prism.DryIoc"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.a,{href:"https://github.com/dadhi/DryIoc",children:"DryIoc"})}),(0,s.jsx)(t.td,{children:"4.0.7"})]})]})]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"Note: There is no need to explicitly install any other dependencies. Installing one of the above packages will also take care of installing the packages for the container as well as the shared Prism packages."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Install Nuget",src:n(2858).A+"",width:"1629",height:"799"})}),"\n",(0,s.jsx)(t.h2,{id:"override-the-existing-application-object",children:"Override the Existing Application Object"}),"\n",(0,s.jsxs)(t.p,{children:["The next step in getting started is to subclass the Application object contained in the newly created WPF project. Navigate to the ",(0,s.jsx)(t.code,{children:"App.xaml"})," and  replace the standard WPF Application class with the Prism ",(0,s.jsx)(t.code,{children:"PrismApplication"})," class."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-xml",children:'<prism:PrismApplication\n    x:Class="WpfApp1.App"\n    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"\n    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"\n    xmlns:local="clr-namespace:WpfApp1"\n    xmlns:prism="http://prismlibrary.com/">\n    <Application.Resources>\n    </Application.Resources>\n</prism:PrismApplication>\n'})}),"\n",(0,s.jsxs)(t.p,{children:["In the snippet above, notice that line 6 has been added to define the namespace and that the App object has been updated to derive from ",(0,s.jsx)(t.code,{children:"PrismApplication"}),". Next, navigate to the ",(0,s.jsx)(t.code,{children:"app.xaml.cs"})," code-behind file and update the class definition."]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["Don't forget to remove the ",(0,s.jsx)(t.code,{children:"StartupUri"})," property from the ",(0,s.jsx)(t.code,{children:"PrismApplication"})," tag. Otherwise, you will end up with two window instances."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cs",children:"using System;\nusing System.Collections.Generic;\nusing System.Configuration;\nusing System.Data;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing Prism.Unity;\n\nnamespace WpfApp1\n{\n    public partial class App : PrismApplication\n    {\n    }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["There are a pair of abstract methods defined in ",(0,s.jsx)(t.code,{children:"PrismApplication"})," that must be implemented first: RegisterTypes and CreateShell."]}),"\n",(0,s.jsx)(t.h3,{id:"registertypes",children:"RegisterTypes"}),"\n",(0,s.jsx)(t.p,{children:"This function is used to register any app dependencies. For example, there might be an interface to read customer data from a persistent store of some kind and the implementation of it is to use a database of some kind. It might look something like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cs",children:"public interface ICustomerStore\n{\n    List<string> GetAll();\n}\n\npublic class DbCustomerStore : ICustomerStore\n{\n    public List<string> GetAll()\n    {\n        // return list from db\n    }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Objects in the app, such as view models, that have a dependency on the customer data would require an ",(0,s.jsx)(t.code,{children:"ICustomerStore"})," object. In the ",(0,s.jsx)(t.code,{children:"App.RegisterTypes"})," function, a registration would be made to create a ",(0,s.jsx)(t.code,{children:"DbCustomerStore"})," every time an object takes a dependency on ",(0,s.jsx)(t.code,{children:"ICustomerStore"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cs",children:"protected override void RegisterTypes(IContainerRegistry containerRegistry)\n{\n    containerRegistry.Register<Services.ICustomerStore, Services.DbCustomerStore>();\n    // register other needed services here\n}\n"})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["IContainerRegistry has other functions for registering against interfaces as well. ",(0,s.jsx)(t.code,{children:"RegisterInstance"})," will register a created instance of an object against an interface. In effect the implementation of the registered interface is a singleton. A similar method is ",(0,s.jsx)(t.code,{children:"RegisterSingleton"})," that will create a single instance at the time the dependency is made and not before. It should be noted that the ",(0,s.jsx)(t.code,{children:"Container"})," can also resolve concrete types without a prior registration."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"createshell",children:"CreateShell"}),"\n",(0,s.jsx)(t.p,{children:"The second method that has to be implemented is the CreateShell method. This is the method that will create the main window of the application. The Container property of the App class should be used to create the window as it takes care of any dependencies."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cs",children:"public partial class App : PrismApplication\n{\n    // RegisterTypes function is here\n\n    protected override Window CreateShell()\n    {\n        var w = Container.Resolve<MainWindow>();\n        return w;\n    }\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"At this point, the app can be built and run and should look like the following:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"First Run of App",src:n(3124).A+"",width:"1227",height:"1165"})}),"\n",(0,s.jsx)(t.p,{children:"This is now a Prism app. There isn't much here yet, but there are lots of things that Prism can help out with, such as breaking up the app into manageable chunks, navigation and implementing the MVVM patterns."}),"\n",(0,s.jsx)(t.h2,{id:"view-models",children:"View Models"}),"\n",(0,s.jsx)(t.p,{children:"WPF is well setup to use an MVVM pattern and Prism helps a lot with this. It has a base class that handles the INotifyPropertyChanged infrastructure that publishes changes from the view model to the view. There are some other classes that make it simple to handle buttons from within the view model as opposed to writing an event handler in your code behind."}),"\n",(0,s.jsxs)(t.p,{children:["First there needs to be some controls added to the view. Go to ",(0,s.jsx)(t.code,{children:"MainWindow.xaml"})," and add the following ",(0,s.jsx)(t.code,{children:"<Grid>"})," markup as the content for the ",(0,s.jsx)(t.code,{children:"<MainWindow>"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-xml",children:'    <Grid>\n        <Grid.RowDefinitions>\n            <RowDefinition Height="*" />\n            <RowDefinition Height="Auto" />\n        </Grid.RowDefinitions>\n\n        <ListView\n            ItemsSource="{Binding Customers}"\n            SelectedItem="{Binding SelectedCustomer}"\n        />\n        <Button\n            Grid.Row="1" Width="80" Height="40"\n            Command="{Binding CommandLoad}"\n            Content="LOAD"\n        />\n    </Grid>\n'})}),"\n",(0,s.jsx)(t.p,{children:"The above will add a new listview that will display a list of customer names and a button to load the list."}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["The important thing to remember is that every time there is a ",(0,s.jsx)(t.code,{children:"Binding"}),", there is a linkage to the view model for this view."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["To help out with this part of the Getting Started Guide, the service that was shown above needs to be setup in the project. In the root of the project, create a ",(0,s.jsx)(t.code,{children:"Services"})," folder. In that folder, create the ",(0,s.jsx)(t.code,{children:"CustomerStore.cs"})," file and add the following code:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cs",children:'    public interface ICustomerStore\n    {\n        List<string> GetAll();\n    }\n\n    public class DbCustomerStore : ICustomerStore\n    {\n        public List<string> GetAll()\n        {\n            return new List<string>()\n            {\n                "cust 1",\n                "cust 2",\n                "cust 3",\n            };\n        }\n    }\n\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Inside the ",(0,s.jsx)(t.code,{children:"App.xaml.cs"})," file, ensure that ",(0,s.jsx)(t.code,{children:"RegisterTypes"})," has the following line:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cs",children:"    containerRegistry.Register<Services.ICustomerStore, Services.DbCustomerStore>();\n"})}),"\n",(0,s.jsx)(t.h2,{id:"creating-the-view-model",children:"Creating the View Model"}),"\n",(0,s.jsxs)(t.p,{children:["First, at the root level of your project, create a folder called ",(0,s.jsx)(t.code,{children:"ViewModels"}),". Use that exact name because that will be needed later when view model resolution is discussed."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Project Folder Structure",src:n(3299).A+"",width:"420",height:"318"})}),"\n",(0,s.jsxs)(t.p,{children:["Inside the ",(0,s.jsx)(t.code,{children:"ViewModels"})," folder, a class is created called ",(0,s.jsx)(t.code,{children:"MainWindowViewModel"}),". Use that exact name for reasons to be shown later. Prism has a class called ",(0,s.jsx)(t.code,{children:"BindableBase"})," that is used as a base for all view models and ",(0,s.jsx)(t.code,{children:"MainWindowViewModel"})," will be subclassed from it."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cs",children:'using Prism.Commands;\nusing Prism.Mvvm;\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace WpfApp1.ViewModels\n{\n    public class MainWindowViewModel : BindableBase\n    {\n        private Services.ICustomerStore _customerStore = null;\n\n        public MainWindowViewModel(Services.ICustomerStore customerStore)\n        {\n            _customerStore = customerStore;\n        }\n\n\n        public ObservableCollection<string> Customers { get; private set; } =\n            new ObservableCollection<string>();\n\n\n        private string _selectedCustomer = null;\n        public string SelectedCustomer\n        {\n            get => _selectedCustomer;\n            set\n            {\n                if (SetProperty<string>(ref _selectedCustomer, value))\n                {\n                    Debug.WriteLine(_selectedCustomer ?? "no customer selected");\n                }\n            }\n        }\n\n        private DelegateCommand _commandLoad = null;\n        public DelegateCommand CommandLoad =>\n            _commandLoad ?? (_commandLoad = new DelegateCommand(CommandLoadExecute));\n\n        private void CommandLoadExecute()\n        {\n            Customers.Clear();\n            List<string> list = _customerStore.GetAll();\n            foreach (string item in list)\n                Customers.Add(item);\n        }\n    }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["A bit of an explanation on what is happening here. MainWindowViewModel has a dependency on the ",(0,s.jsx)(t.code,{children:"ICustomerStore"})," interface, so that interface has to be registered in the ",(0,s.jsx)(t.code,{children:"App.RegisterTypes"})," so that its implementation can be handled by the dependency container. There is a ",(0,s.jsx)(t.code,{children:"Customers"})," property that is bound to the listview in the user interface and a ",(0,s.jsx)(t.code,{children:"SelectedCustomer"})," that is bound to the currently selected item in the list view."]}),"\n",(0,s.jsxs)(t.p,{children:["There is also CommandLoad object that implements the ",(0,s.jsx)(t.code,{children:"ICommand"})," interface. This has an ",(0,s.jsx)(t.code,{children:"Execute"})," method that is called when the user clicks on the button. Prism implements the ",(0,s.jsx)(t.code,{children:"ICommand"})," interface with ",(0,s.jsx)(t.code,{children:"DelegateCommand"})," class that allows delegates to be passed in to handle implementing the ",(0,s.jsx)(t.code,{children:"ICommand"})," interface. In the case of ",(0,s.jsx)(t.code,{children:"CommandLoad"}),", the ",(0,s.jsx)(t.code,{children:"CommandLoadExecute"})," function is passed in as the delegate and now, whenever the WPF binding system tries to execute ",(0,s.jsx)(t.code,{children:"ICommand.Execute"}),", ",(0,s.jsx)(t.code,{children:"CommandLoadExecute"})," is invoked."]}),"\n",(0,s.jsxs)(t.p,{children:["For more details on DelegateCommand, see ",(0,s.jsx)(t.a,{href:"/docs/9.0/commands/commanding",children:"Commanding"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"using-the-viewmodellocator",children:"Using the ViewModelLocator"}),"\n",(0,s.jsxs)(t.p,{children:["Now there is a View and a ViewModel, but how are they linked together? Out of the box, Prism has a ",(0,s.jsx)(t.code,{children:"ViewModelLocator"})," that uses convention to determine the correct class for the view model, instantiate it with its dependencies and attach it to the ",(0,s.jsx)(t.code,{children:"DataContext"})," of the view."]}),"\n",(0,s.jsxs)(t.p,{children:["The default convention is to place all the views in the ",(0,s.jsx)(t.code,{children:"Views"})," folder and the view models in the ",(0,s.jsx)(t.code,{children:"ViewModels"})," folder."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"WpfApp1.Views.MainWindow"})," => ",(0,s.jsx)(t.code,{children:"WpfApp1.ViewModels.MainWindowViewModel"})]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"WpfApp1.Views.OtherView"})," => ",(0,s.jsx)(t.code,{children:"WpfApp1.ViewModels.OtherViewModel"})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This is configurable and different resolution logic can be added."}),"\n",(0,s.jsx)(t.p,{children:"For this to work, Views and ViewModels must be properly located within their correct name spaces. Below is a screen shot of what that would look like:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Viewmodel Locator Project Structure",src:n(3997).A+"",width:"472",height:"386"})}),"\n",(0,s.jsxs)(t.p,{children:["Click ",(0,s.jsx)(t.a,{href:"/docs/9.0/mvvm/viewmodel-locator",children:"here"})," for detailed information on the ",(0,s.jsx)(t.code,{children:"ViewModelLocator"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"If you don't want to use this capability for some reason, you will have to opt out in your view. You can manage this in your XAML as follows:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-xml",children:'<Window\n    ...\n    xmlns:prism="http://prismlibrary.com/"\n    prism:ViewModelLocator.AutoWireViewModel="False"\n    >\n\n\t\x3c!-- ui controls here --\x3e\n</Window>\n'})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);