"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[2688],{8453:(e,t,s)=>{s.d(t,{R:()=>n,x:()=>a});var r=s(6540);const o={},i=r.createContext(o);function n(e){const t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:n(e.components),r.createElement(i.Provider,{value:t},e.children)}},9896:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>n,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"plugins/essentials/io/stores","title":"Stores","description":"The concept of Stores is borrowed from one of our favorite .NET Libraries Shiny.NET, however we\'ve made a few enhancements and provided implementations for all of your Prism applications. One of the root concepts of Stores is that the store implementation should be decoupled from any logic around how it is used. This means that unit testing is particularly easy.","source":"@site/docs/plugins/essentials/io/stores.md","sourceDirName":"plugins/essentials/io","slug":"/plugins/essentials/io/stores","permalink":"/docs/current/plugins/essentials/io/stores","draft":false,"unlisted":false,"editUrl":"https://github.com/PrismLibrary/Prism-Documentation/edit/master/docs/plugins/essentials/io/stores.md","tags":[],"version":"current","lastUpdatedBy":"Dan Siegel","lastUpdatedAt":1763924282000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"uid":"Plugins.Essentials.Stores"},"sidebar":"tutorialSidebar","previous":{"title":"File System","permalink":"/docs/current/plugins/essentials/io/filesystem"},"next":{"title":"Getting Started","permalink":"/docs/current/plugins/essentials/media/"}}');var o=s(4848),i=s(8453);const n={sidebar_position:2,uid:"Plugins.Essentials.Stores"},a="Stores",l={},c=[{value:"Available Stores",id:"available-stores",level:2},{value:"Creating a store",id:"creating-a-store",level:2},{value:"What The Source Generator will do",id:"what-the-source-generator-will-do",level:3},{value:"Registering your Store",id:"registering-your-store",level:2},{value:"Providing Default Values",id:"providing-default-values",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"stores",children:"Stores"})}),"\n",(0,o.jsxs)(t.p,{children:["The concept of Stores is borrowed from one of our favorite .NET Libraries ",(0,o.jsx)(t.a,{href:"https://shinylib.net/",children:"Shiny.NET"}),", however we've made a few enhancements and provided implementations for all of your Prism applications. One of the root concepts of Stores is that the store implementation should be decoupled from any logic around how it is used. This means that unit testing is particularly easy."]}),"\n",(0,o.jsxs)(t.p,{children:["To get started you will need a reference to ",(0,o.jsx)(t.code,{children:"Prism.Plugin.Essentials"}),". Note that this could be a transitive reference from the platform specific package for ",(0,o.jsx)(t.code,{children:"Prism.Plugin.Essentials"}),". However you may use the root package for libraries that you wish to keep decoupled from platform specific references. The first thing to consider when building a store is what properties you may want to expose."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:"public interface IMyStore\n{\n    string MyProperty { get; set; }\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"available-stores",children:"Available Stores"}),"\n",(0,o.jsx)(t.p,{children:"We currently support 3 stores by default. You can choose the store that makes the most sense for your specific application, and you can have multiple interfaces which utilize the same or different stores throughout your application."}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Memory Store - This is particular helpful for scenarios where you only need the values to remain in scope during the lifecycle of the application and you can revert back to a default state the next time the app is launched."}),"\n",(0,o.jsx)(t.li,{children:"Settings Store - This is useful for a wide degree of persistent values that you want to store and which do not present security concerns."}),"\n",(0,o.jsx)(t.li,{children:"Secure Store - This is useful for that last scenario where you need both persistence and to take advantage of the platform's built in ability to secure values. (NOTE: While this is implemented across all Prism platforms, some heads such as WASM do not support a Secure Store)"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"creating-a-store",children:"Creating a store"}),"\n",(0,o.jsx)(t.p,{children:"As you noticed from the example above our store does not implement anything. In fact it simply needs to be an interface with properties that have both a get and set. However to actually make use of the store we must do 2 things."}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"We must provide an attribute for the Store type that we want to have implemented."}),"\n",(0,o.jsx)(t.li,{children:"We must make the interface partial"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:"[SecureStore]\npublic partial interface IMyStore\n{\n    string MyProperty { get; set; }\n}\n"})}),"\n",(0,o.jsx)(t.h3,{id:"what-the-source-generator-will-do",children:"What The Source Generator will do"}),"\n",(0,o.jsxs)(t.p,{children:["Under the covers a source generator will provide both an implementation for your interface using the specified store type, and it will provide a class that implements ",(0,o.jsx)(t.code,{children:"INotifyPropertyChanged"})," so that you can actually Bind directly to any property on your Store."]}),"\n",(0,o.jsxs)(t.p,{children:["The next thing it will do is provide a Clear method. In the implementation it will clear out ONLY the properties specified as part of the interface. This means that other code that may be making use of the given store will never directly lose their values when you call clear unless you specifically get the KeyValueStore from the ",(0,o.jsx)(t.code,{children:"IKeyValueStoreFactory"})," and clear all of the values for that specific store."]}),"\n",(0,o.jsx)(t.h2,{id:"registering-your-store",children:"Registering your Store"}),"\n",(0,o.jsx)(t.p,{children:"As mentioned you will need to be sure to have the platform specific package when registering the Store, however you do not need it for the Store itself. In order to register your store you can simply call the extension"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:"containerRegistry.RegisterStore<IMyStore>();\n"})}),"\n",(0,o.jsx)(t.h2,{id:"providing-default-values",children:"Providing Default Values"}),"\n",(0,o.jsx)(t.p,{children:"You may want to provide a default value for your properties. You can do this with the DefaultValue attribute from System.ComponentModel."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:"[SettingsStore]\npublic partial interface IMyStore\n{\n    [DefaultValue(true)]\n    bool RememberMe { get; set; }\n}\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);