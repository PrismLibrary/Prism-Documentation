"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[4359],{8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var t=n(6540);const s={},r=t.createContext(s);function o(e){const i=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:i},e.children)}},8935:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"dependency-injection/registering-types","title":"Registering Types with Prism","description":"Similar to most Dependency Injection models, Prism provides abstractions around 3 service lifetimes:","source":"@site/versioned_docs/version-9.0/dependency-injection/registering-types.md","sourceDirName":"dependency-injection","slug":"/dependency-injection/registering-types","permalink":"/docs/9.0/dependency-injection/registering-types","draft":false,"unlisted":false,"editUrl":"https://github.com/PrismLibrary/Prism-Documentation/edit/master/versioned_docs/version-9.0/dependency-injection/registering-types.md","tags":[],"version":"9.0","lastUpdatedBy":"Dan Siegel","lastUpdatedAt":1763924282000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"uid":"DependencyInjection.RegisterServices"},"sidebar":"tutorialSidebar","previous":{"title":"Dependency Injection with Prism","permalink":"/docs/9.0/dependency-injection/"},"next":{"title":"Dependency Injection - Supplement","permalink":"/docs/9.0/dependency-injection/servicecollection-supplement"}}');var s=n(4848),r=n(8453);const o={sidebar_position:2,uid:"DependencyInjection.RegisterServices"},a="Registering Types with Prism",c={},l=[{value:"Registering Transient Services",id:"registering-transient-services",level:2},{value:"Registering Singleton Services",id:"registering-singleton-services",level:2},{value:"Registering a Service Instance",id:"registering-a-service-instance",level:3},{value:"Checking if a Service has been Registered",id:"checking-if-a-service-has-been-registered",level:2},{value:"Lazy Resolution",id:"lazy-resolution",level:2},{value:"Resolve All",id:"resolve-all",level:2}];function d(e){const i={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"registering-types-with-prism",children:"Registering Types with Prism"})}),"\n",(0,s.jsx)(i.p,{children:"Similar to most Dependency Injection models, Prism provides abstractions around 3 service lifetimes:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Transient (Get a new instance every time the service or type is requested)"}),"\n",(0,s.jsx)(i.li,{children:"Singleton (Get the same instance every time the service or type is requested)"}),"\n",(0,s.jsx)(i.li,{children:"Scoped (Get a new instance on each container scope, but the same instance within a specific container scope)"}),"\n"]}),"\n",(0,s.jsx)(i.admonition,{type:"note",children:(0,s.jsxs)(i.p,{children:["By default Prism does not use scoping except within Prism.Maui which creates a scope around each Page. This is used for services such as the ",(0,s.jsx)(i.code,{children:"INavigationService"}),", ",(0,s.jsx)(i.code,{children:"IPageDialogService"}),", and ",(0,s.jsx)(i.code,{children:"IDialogService"}),"."]})}),"\n",(0,s.jsx)(i.p,{children:"For those who may be familiar with ASP.NET Core you may be familiar with 3 basic types of dependency registrations: Transients, Singletons, and Scoped Services. Unlike the web environment in which many of your services are scoped around the User Request, for Desktop and Mobile applications we are dealing with a single user. As a result, we must instead decide whether for memory management and other business requirements our services are best suited as a single instance that will be reused throughout our application or whether we will create a new instance each time it is requested and then allow the Garbage Collector to free up the memory when we are done with it."}),"\n",(0,s.jsxs)(i.p,{children:["It is also important to consider that Prism has a hard requirement on the use of named service registrations. This is what allows Prism to register your Page for navigation and then resolve it later based on the Uri segment like ",(0,s.jsx)(i.code,{children:"MyMasterDetailPage/NavigationPage/ViewA"}),". Any Dependency Injection container which does not support named services out of the box therefore cannot and will not be implemented officially by the Prism team."]}),"\n",(0,s.jsx)(i.h2,{id:"registering-transient-services",children:"Registering Transient Services"}),"\n",(0,s.jsxs)(i.p,{children:["For those services that you expect to create a new instance each time it is created you will simply call the ",(0,s.jsx)(i.code,{children:"Register"})," method and provide the Service Type and the Implementing Type, except in cases where it may be appropriate to simply register the concrete type."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cs",children:"// Where it will be appropriate to use FooService as a concrete type\ncontainerRegistry.Register<FooService>();\n\ncontainerRegistry.Register<IBarService, BarService>();\n"})}),"\n",(0,s.jsx)(i.h2,{id:"registering-singleton-services",children:"Registering Singleton Services"}),"\n",(0,s.jsx)(i.p,{children:"Many times you may have a service which is used throughout your application. As a result it would not be a good idea to create a new instance every time you need the service. In order to provide better memory management it is therefore a better practice to make such services a Singleton that can be used throughout the application. There are also many times in which you may need a service that retains it state throughout the lifecycle of your application. For either of these cases it makes far more sense to register your service as a Singleton."}),"\n",(0,s.jsx)(i.admonition,{type:"note",children:(0,s.jsx)(i.p,{children:"Singleton Services are not actually created, and therefore do not start using memory until the first time the service is resolved by your application."})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cs",children:"// Where it will be appropriate to use FooService as a concrete type\ncontainerRegistry.RegisterSingleton<FooService>();\n\ncontainerRegistry.RegisterSingleton<IBarService, BarService>();\n"})}),"\n",(0,s.jsx)(i.h3,{id:"registering-a-service-instance",children:"Registering a Service Instance"}),"\n",(0,s.jsx)(i.p,{children:"While many times you'll want to register a Singleton by simply providing the Service and Implementation types, there are times in which you may want to new up a service instance and provide it for a given service, or in which you may want to register the Current instance from a plugin such as MonkeyCache as shown below:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cs",children:'containerRegistry.RegisterInstance<IFoo>(new FooImplementation());\n\n// Sample of using James Montemagno\'s Monkey Cache\nBarrel.ApplicationId = "your_unique_name_here";\ncontainerRegistry.RegisterInstance<IBarrel>(Barrel.Current);\n'})}),"\n",(0,s.jsx)(i.h2,{id:"checking-if-a-service-has-been-registered",children:"Checking if a Service has been Registered"}),"\n",(0,s.jsx)(i.p,{children:"There are many times particularly when writing Prism Modules or Plugins in which you may want to check if a service has been registered and then do something based on whether it has or has not been registered."}),"\n",(0,s.jsx)(i.admonition,{type:"note",children:(0,s.jsxs)(i.p,{children:["When working with Prism Modules if you have a hard dependency on a given service it should be injected into the constructor so as to generate an exception when initializing the Module if the service type is missing. You should only use ",(0,s.jsx)(i.code,{children:"IsRegistered"})," to check for it if your intent is to register a default implementation."]})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cs",children:"if (containerRegistry.IsRegistered<ISomeService>())\n{\n    // Do something...\n}\n"})}),"\n",(0,s.jsx)(i.h2,{id:"lazy-resolution",children:"Lazy Resolution"}),"\n",(0,s.jsxs)(i.p,{children:["As shown previously you can register your services like ",(0,s.jsx)(i.code,{children:"containerRegistry.Register<IFoo, Foo>()"}),". Many developers may have use cases where they want to conserve memory and lazy load services either as ",(0,s.jsx)(i.code,{children:"Func<IFoo>"})," or ",(0,s.jsx)(i.code,{children:"Lazy<IFoo>"}),". Prism 8 supports this out of the box. In order to do this you simply need to add the parameter to your ViewModel or Service as shown below."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cs",children:"public class ViewAViewModel\n{\n    public ViewAViewModel(Func<IFoo> fooFactory, Lazy<IBar> lazyBar)\n    {\n    }\n}\n"})}),"\n",(0,s.jsx)(i.admonition,{type:"note",children:(0,s.jsxs)(i.p,{children:["Take note of the service registration type. It generally does NOT make sense to use ",(0,s.jsx)(i.code,{children:"Lazy<T>"})," or ",(0,s.jsx)(i.code,{children:"Func<T>"})," resolutions when you are working with a Singleton Service. For instance the ",(0,s.jsx)(i.code,{children:"IEventAggregator"})," is a singleton. This means that you get a single instance of the Event Aggregator that is used through the entire application. By using ",(0,s.jsx)(i.code,{children:"Lazy<T>"})," or ",(0,s.jsx)(i.code,{children:"Func<T>"})," you ultimately use more memory and may take performance hits instead of just requesting the service outright."]})}),"\n",(0,s.jsx)(i.h2,{id:"resolve-all",children:"Resolve All"}),"\n",(0,s.jsxs)(i.p,{children:["Some Developers may find the need to Register multiple implementations of the same service contract with an expectation of resolving all of them. As a common use case, Shiny uses this pattern with some of its delegate interfaces. This can allow you to build more modular code by responding to the same event in bite sized chunks. Again there is nothing special that you need to do with the registration. To use this feature you simply need to inject ",(0,s.jsx)(i.code,{children:"IEnumerable<T>"})," into your constructor as show here."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cs",children:"public class SomeService\n{\n    public SomeService(IEnumerable<IFoo> fooCollection)\n    {\n    }\n}\n"})}),"\n",(0,s.jsx)(i.admonition,{type:"note",children:(0,s.jsx)(i.p,{children:"This feature is only supported in DryIoc at this time. This may become available to those using Unity Container once version 6 releases."})})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);