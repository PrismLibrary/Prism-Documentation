"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[1471],{5445:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>l,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"navigation/regions/navigation-existing-views","title":"Navigating to Existing Views","description":"Frequently, it is more appropriate for the views in your application to be re-used, updated, or activated during navigation, instead of replaced by a new view. This is often the case where you are navigating to the same type of view but need to display different information or state to the user, or when the appropriate view is already available in the UI but needs to be activated (that is, selected or made top-most).","source":"@site/docs/navigation/regions/navigation-existing-views.md","sourceDirName":"navigation/regions","slug":"/navigation/regions/navigation-existing-views","permalink":"/docs/current/navigation/regions/navigation-existing-views","draft":false,"unlisted":false,"editUrl":"https://github.com/PrismLibrary/Prism-Documentation/edit/master/docs/navigation/regions/navigation-existing-views.md","tags":[],"version":"current","lastUpdatedBy":"Dan Siegel","lastUpdatedAt":1763924282000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7,"uid":"Navigation.Regions.NavigationExistingViews"},"sidebar":"tutorialSidebar","previous":{"title":"View and View Model Participation in Navigation","permalink":"/docs/current/navigation/regions/view-viewmodel-participation"},"next":{"title":"Passing Parameters During Navigation","permalink":"/docs/current/navigation/regions/passing-parameters"}}');var a=i(4848),o=i(8453);const s={sidebar_position:7,uid:"Navigation.Regions.NavigationExistingViews"},r="Navigating to Existing Views",d={},c=[];function h(e){const t={admonition:"admonition",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"navigating-to-existing-views",children:"Navigating to Existing Views"})}),"\n",(0,a.jsx)(t.p,{children:"Frequently, it is more appropriate for the views in your application to be re-used, updated, or activated during navigation, instead of replaced by a new view. This is often the case where you are navigating to the same type of view but need to display different information or state to the user, or when the appropriate view is already available in the UI but needs to be activated (that is, selected or made top-most)."}),"\n",(0,a.jsxs)(t.p,{children:["For an example of the first scenario, imagine that your application allows the user to edit customer records, using the ",(0,a.jsx)(t.strong,{children:"EditCustomer"})," view, and the user is currently using that view to edit customer ID 123. If the customer decides to edit the customer record for customer ID 456, the user can simply navigate to the ",(0,a.jsx)(t.strong,{children:"EditCustomer"})," view and enter the new customer ID. The ",(0,a.jsx)(t.strong,{children:"EditCustomer"})," view can then retrieve the data for the new customer and update its UI accordingly."]}),"\n",(0,a.jsxs)(t.p,{children:["An example of the second scenario is where the application allows the user to edit more than one customer record at a time. In this case, the application displays multiple ",(0,a.jsx)(t.strong,{children:"EditCustomer"})," view instances in a tab control\u2014for example, one for customer ID 123 and another for customer ID 456. When the user navigates to the ",(0,a.jsx)(t.strong,{children:"EditCustomer"})," view and enters customer ID 456, the corresponding view will be activated (that is, its corresponding tab will be selected). If the user navigates to the ",(0,a.jsx)(t.strong,{children:"EditCustomer"})," view and enters customer ID 789, a new instance will be created and displayed in the tab control."]}),"\n",(0,a.jsx)(t.p,{children:"The ability to navigate to an existing view is useful for a variety of reasons. It is often more efficient to update an existing view instead of replace it with a new instance of the same type. Similarly, activating an existing view, instead of creating a duplicate view, provides a more consistent user experience. In addition, the ability to handle these situations seamlessly without requiring much custom code means that the application is easier to develop and maintain."}),"\n",(0,a.jsxs)(t.p,{children:["Prism supports the two scenarios described earlier via the ",(0,a.jsx)(t.strong,{children:"IsNavigationTarget"})," method on the ",(0,a.jsx)(t.strong,{children:"INavigationAware"})," interface. This method is called during navigation on all views in a region that are of the same type as the target view. In the preceding examples, the target type of the view is the ",(0,a.jsx)(t.strong,{children:"EditCustomer"})," view, so the ",(0,a.jsx)(t.strong,{children:"IsNavigationTarget"})," method will be called on all existing ",(0,a.jsx)(t.strong,{children:"EditCustomer"})," view instances currently in the region. Prism determines the target type from the view URI, which it assumes is the short type name of the target type."]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["For Prism to determine the type of the target view, the view's name in the navigation URI should be the same as the actual target type's short type name. For example, if your view is implemented by the ",(0,a.jsx)(t.strong,{children:"MyApp.Views.EmployeeDetailsView"})," class, the view name specified in the navigation URI should be ",(0,a.jsx)(t.strong,{children:"EmployeeDetailsView"}),". This is the default behavior provided by Prism. You can customize this behavior by implementing a custom content loader class: do this by implementing the ",(0,a.jsx)(t.strong,{children:"IRegionNavigationContentLoader"})," interface or by deriving from the ",(0,a.jsx)(t.strong,{children:"RegionNavigationContentLoader"})," class."]})}),"\n",(0,a.jsxs)(t.p,{children:["The implementation of the ",(0,a.jsx)(t.strong,{children:"IsNavigationTarget"})," method can use the ",(0,a.jsx)(t.strong,{children:"NavigationContext"})," parameter to determine whether it can handle the navigation request. The ",(0,a.jsx)(t.strong,{children:"NavigationContext"})," object provides access to the navigation URI and the navigation parameters. In the preceding examples, the implementation of this method in the ",(0,a.jsx)(t.strong,{children:"EditCustomer"})," view model compares the current customer ID to the ID specified in the navigation request, and it returns ",(0,a.jsx)(t.strong,{children:"true"})," if they match."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cs",children:'public class EmployeeDetailsViewModel : BindableBase, INavigationAware\n{\n    public bool IsNavigationTarget(NavigationContext navigationContext)\n    {\n        string id = navigationContext.Parameters["ID"];\n        return _currentCustomer.Id.Equals(id);\n    }\n\n    public void OnNavigatedTo(NavigationContext navigationContext) { }\n    public void OnNavigatedFrom(NavigationContext navigationContext) { }\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["If the ",(0,a.jsx)(t.strong,{children:"IsNavigationTarget"})," method always returns ",(0,a.jsx)(t.strong,{children:"true"}),", regardless of the navigation parameters, that view instance will always be re-used. This allows you to ensure that only one view of a particular type will be displayed in a particular region."]})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>r});var n=i(6540);const a={},o=n.createContext(a);function s(e){const t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);