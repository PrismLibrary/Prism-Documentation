"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[6886],{3613:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"platforms/maui/navigation/page-navigation","title":"Page Navigation","description":"For those who may be familiar with Prism.Forms this is perhaps one of the most beloved features of Prism. Prism\'s INavigationService provides us the ability to easily navigate between pages with a powerful understanding of URI\'s. This allows us to inject parameters into the URI\'s that will be passed to specific Pages, overload query parameters, and even control the behavior of the navigation such as whether or not to animate the transition or navigate modally at a specific URI segment.","source":"@site/versioned_docs/version-9.0/platforms/maui/navigation/page-navigation.md","sourceDirName":"platforms/maui/navigation","slug":"/platforms/maui/navigation/page-navigation","permalink":"/docs/9.0/platforms/maui/navigation/page-navigation","draft":false,"unlisted":false,"editUrl":"https://github.com/PrismLibrary/Prism-Documentation/edit/master/versioned_docs/version-9.0/platforms/maui/navigation/page-navigation.md","tags":[],"version":"9.0","lastUpdatedBy":"Dan Siegel","lastUpdatedAt":1763924282000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Getting Started","permalink":"/docs/9.0/platforms/maui/navigation/"},"next":{"title":"Navigation Builder","permalink":"/docs/9.0/platforms/maui/navigation/navigation-builder"}}');var n=t(4848),o=t(8453);const s={sidebar_position:2},r="Page Navigation",l={},h=[{value:"What the heck is a Navigation Segment?",id:"what-the-heck-is-a-navigation-segment",level:2},{value:"Known Navigation Parameters",id:"known-navigation-parameters",level:2},{value:"Navigation Parameters",id:"navigation-parameters",level:2},{value:"Navigation Methods",id:"navigation-methods",level:2},{value:"NavigateAsync",id:"navigateasync",level:3},{value:"FlyoutPages",id:"flyoutpages",level:4},{value:"Deep Linking",id:"deep-linking",level:4},{value:"Absolute vs Relative Navigation",id:"absolute-vs-relative-navigation",level:4},{value:"GoBackAsync",id:"gobackasync",level:3},{value:"GoBackToRootAsync",id:"gobacktorootasync",level:3}];function d(e){const a={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.header,{children:(0,n.jsx)(a.h1,{id:"page-navigation",children:"Page Navigation"})}),"\n",(0,n.jsx)(a.p,{children:"For those who may be familiar with Prism.Forms this is perhaps one of the most beloved features of Prism. Prism's INavigationService provides us the ability to easily navigate between pages with a powerful understanding of URI's. This allows us to inject parameters into the URI's that will be passed to specific Pages, overload query parameters, and even control the behavior of the navigation such as whether or not to animate the transition or navigate modally at a specific URI segment."}),"\n",(0,n.jsx)(a.admonition,{type:"note",children:(0,n.jsx)(a.p,{children:"Page based navigation in .NET MAUI is specific to the individual page you want to navigate from. This is NOT a concept unique to Prism, but is actually a fundamental part of how navigation within .NET MAUI works. As a result, Prism relies on Dependency Injection Container Scoping around the creation of Each Page to ensure that we inject an instance of the Navigation Service that has the ability to navigate from the corresponding Page for the current scope."})}),"\n",(0,n.jsx)(a.h2,{id:"what-the-heck-is-a-navigation-segment",children:"What the heck is a Navigation Segment?"}),"\n",(0,n.jsxs)(a.p,{children:["You may see the term ",(0,n.jsx)(a.code,{children:"Navigation Segment"})," used several times throughout the docs, but what is it? Given that you have a URI that looks like ",(0,n.jsx)(a.code,{children:"ViewA/ViewB/ViewC"}),", we will split the URI into 3 segments, ",(0,n.jsx)(a.code,{children:"ViewA"}),", ",(0,n.jsx)(a.code,{children:"ViewB"}),", and ",(0,n.jsx)(a.code,{children:"ViewC"}),". Each segment may contain it's own query parameters which are only passed to that specific Page during the navigation. An example of this would be ",(0,n.jsx)(a.code,{children:"ViewA?color=Red/ViewB?color=Blue/ViewC?color=Green"}),". In this example ",(0,n.jsx)(a.code,{children:"ViewA"})," will have a query parameter of ",(0,n.jsx)(a.code,{children:"color=Red"})," and ",(0,n.jsx)(a.code,{children:"ViewB"})," will have a query parameter of ",(0,n.jsx)(a.code,{children:"color=Blue"})," and ",(0,n.jsx)(a.code,{children:"ViewC"})," will have a query parameter of ",(0,n.jsx)(a.code,{children:"color=Green"}),"."]}),"\n",(0,n.jsx)(a.h2,{id:"known-navigation-parameters",children:"Known Navigation Parameters"}),"\n",(0,n.jsx)(a.p,{children:'Prism.Maui has a number of "KnownNavigationParameters" that you can use to control the behavior of the navigation. Each of these parameter names can be accessed from the KnownNavigationParameters class.'}),"\n",(0,n.jsxs)(a.table,{children:[(0,n.jsx)(a.thead,{children:(0,n.jsxs)(a.tr,{children:[(0,n.jsx)(a.th,{children:"Property"}),(0,n.jsx)(a.th,{children:"Value"}),(0,n.jsx)(a.th,{children:"Description"})]})}),(0,n.jsxs)(a.tbody,{children:[(0,n.jsxs)(a.tr,{children:[(0,n.jsx)(a.td,{children:(0,n.jsx)(a.code,{children:"CreateTab"})}),(0,n.jsx)(a.td,{children:(0,n.jsx)(a.code,{children:"createTab"})}),(0,n.jsxs)(a.td,{children:["This parameter will be evaluated by the Navigation Service when the parameter exists on a TabbedPage. This parameter is commonly overloaded like ",(0,n.jsx)(a.code,{children:"TabbedPage?createTab=ViewA&createTab=ViewB"}),". This will create a new TabbedPage with 2 tabs, one for ViewA and one for ViewB."]})]}),(0,n.jsxs)(a.tr,{children:[(0,n.jsx)(a.td,{children:(0,n.jsx)(a.code,{children:"SelectedTab"})}),(0,n.jsx)(a.td,{children:(0,n.jsx)(a.code,{children:"selectedTab"})}),(0,n.jsxs)(a.td,{children:["This parameter will be evaluated by the Navigation Service when the parameter exists on a TabbedPage. This parameter should not be overloaded. Most commonly you would use the name of the tab you want to select like ",(0,n.jsx)(a.code,{children:"TabbedPage?selectedTab=ViewA"}),". This will select the tab with the name of ViewA. In the event that you have a NavigationPage on the tab, you may want to use the alternate syntax like `TabbedPage?selectedTab=NavigationPage"]})]}),(0,n.jsxs)(a.tr,{children:[(0,n.jsx)(a.td,{children:(0,n.jsx)(a.code,{children:"UseModalNavigation"})}),(0,n.jsx)(a.td,{children:(0,n.jsx)(a.code,{children:"useModalNavigation"})}),(0,n.jsxs)(a.td,{children:["When this parameter is present on any navigation segment, the page will be pushed modally if the value is true, and we will not push modally if it is false. Note that this may cause a Navigation failure if we cannot navigate the way you want from the current context. This parameter can be used when invoking ",(0,n.jsx)(a.code,{children:"NavigateAsync"})," or ",(0,n.jsx)(a.code,{children:"GoBackAsync"}),"."]})]}),(0,n.jsxs)(a.tr,{children:[(0,n.jsx)(a.td,{children:(0,n.jsx)(a.code,{children:"Animated"})}),(0,n.jsx)(a.td,{children:(0,n.jsx)(a.code,{children:"animated"})}),(0,n.jsx)(a.td,{children:"When this parameter is present we will override the default behavior to animate the navigation. If you do not want to animate the entire navigation you may want to pass this in the NavigationParameters rather than the URI as the URI would require you to pass this on each segment."})]})]})]}),"\n",(0,n.jsx)(a.h2,{id:"navigation-parameters",children:"Navigation Parameters"}),"\n",(0,n.jsx)(a.p,{children:"As has already been mentioned Prism allows you to easily pass parameters to specific Pages with query parameters. These are added to the Navigation Parameter that you may pass into various Navigation methods. The Navigation Parameters are passed to all pages that may be created during the navigation process. NavigationParameters are vary similar to an IDictionary but are not limited to a single entry of a key/value pair."}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-cs",children:'var parameters = new NavigationParameters\n{\n    { "color", "Red" },\n    { "color", "Blue" },\n    { "color", "Green" },\n    { "size", "Large" }\n}\n'})}),"\n",(0,n.jsxs)(a.p,{children:["This allows you to pass parameters one at a time to the NavigationParameters if you need to. NavigationParameter are implemented as an ",(0,n.jsx)(a.code,{children:"IEnumerable<KeyValuePair<string, object>>"}),", so as a result you can pass any value type that you require and overload Keys."]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-cs",children:'var parameters = new NavigationParameters\n{\n    { "color", new [] { "Red", "Blue", "Green" } },\n    { "size", "Large" }\n}\n'})}),"\n",(0,n.jsx)(a.h2,{id:"navigation-methods",children:"Navigation Methods"}),"\n",(0,n.jsxs)(a.p,{children:["The actual ",(0,n.jsx)(a.code,{children:"INavigationService"})," interface is kept as clean as possible with 3 core methods. Everything else you see in Intellisense is an extension method which is meant to help you just provide the parameters you need."]}),"\n",(0,n.jsx)(a.h3,{id:"navigateasync",children:"NavigateAsync"}),"\n",(0,n.jsxs)(a.p,{children:["The ",(0,n.jsx)(a.code,{children:"NavigateAsync"})," method is one of most critical core concepts to building apps with Prism. This is where we accomplish setting the Page on our Application Window and updating the Navigation Stack by pushing pages Modally or non-Modally within our app. We can also use this method to dynamically set the FlyoutPage's Detail, add a page to a brand new NavigationPage, or even create an entire TabbedPage on the fly. We do this all through the requested Navigation URI. As has been already discussed the Navigation Service break apart the Navigation URI and process each segment. It is extremely intelligent in figuring out the context it needs to navigate. As a result, when Navigating from a FlyoutPage the Navigation Service understands that the next page will set the Detail of the FlyoutPage. When navigating within the context of a NavigationPage, the Navigation Service understands that the next page will be added to the NavigationPage and will not be pushed Modally."]}),"\n",(0,n.jsx)(a.h4,{id:"flyoutpages",children:"FlyoutPages"}),"\n",(0,n.jsx)(a.p,{children:'FlyoutPages in .NET MAUI are a special page that commonly provides the "Hamburger Menu" in the upper left hand corner of the app. You may swipe left to right to reveal or hide the menu or you may tap the Hamburger Menu depending on the platform and settings. Understanding how the FlyoutPage works though is critical to ensure that you use it correctly. The FlyoutPage has two primary properties that you should understand, both of which are a Page.'}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:(0,n.jsx)(a.code,{children:"FlyoutPage.Flyout"})}),"\n",(0,n.jsx)(a.li,{children:(0,n.jsx)(a.code,{children:"FlyoutPage.Detail"})}),"\n"]}),"\n",(0,n.jsx)(a.p,{children:"Within the context of a Prism Application you should NEVER directly set Detail as this should be set dynamically by the NavigationService."}),"\n",(0,n.jsx)(a.p,{children:"The Flyout itself may be a bit tricker for some to understand. The reality is that this never should have been a Page type, the best way to think of this is that you have a ContentView that we've decided to call ContentPage instead. The ContentPage that we're using for the Flyout should NOT have it's own ViewModel."}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-xml",children:'<FlyoutPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"\n            xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"\n            x:Class="AwesomeApp.MainPage">\n  <FlyoutPage.Flyout>\n    <ContentPage Title="Menu">\n        \x3c!-- Your Content Here --\x3e\n    </ContentPage>\n  </FlyoutPage.Flyout>\n</FlyoutPage>\n'})}),"\n",(0,n.jsx)(a.admonition,{type:"note",children:(0,n.jsxs)(a.p,{children:["In some cases you may find that you do not even need a ViewModel for the FlyoutPage if simply have a static view with a Menu that uses the ",(0,n.jsx)(a.a,{href:"/docs/9.0/platforms/maui/navigation/xaml-navigation",children:"Xaml Navigation Extensions"})]})}),"\n",(0,n.jsx)(a.p,{children:"If we were building a .NET MAUI application without the benefit of Prism, we would expect to set a NavigationPage as the Detail of the FlyoutPage, and then push our ContentPage into the NavigationPage. From code this might look something like:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-cs",children:'var mainPage = new FlyoutPage()\n{\n    Flyout = new ContentPage()\n    {\n        Title = "Menu",\n        Content = new StackLayout()\n        {\n            Children =\n            {\n                new Label()\n                {\n                    Text = "Hello World"\n                }\n            }\n        }\n    },\n    Detail = new NavigationPage(new ContentPage()\n    {\n        Title = "Content Page",\n        Content = new StackLayout()\n        {\n            Children =\n            {\n                new Label()\n                {\n                    Text = "Hello World"\n                }\n            }\n        }\n    })\n};\n'})}),"\n",(0,n.jsx)(a.p,{children:"As already mentioned you should never set the Detail property of the FlyoutPage. Instead we will do this with the Navigation URI. Our Navigation might look something like:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-cs",children:'Navigation.NavigateAsync("MyFlyoutPage/NavigationPage/ViewA");\n'})}),"\n",(0,n.jsx)(a.h4,{id:"deep-linking",children:"Deep Linking"}),"\n",(0,n.jsx)(a.h4,{id:"absolute-vs-relative-navigation",children:"Absolute vs Relative Navigation"}),"\n",(0,n.jsxs)(a.p,{children:["A URI has two basic states, absolute and relative. Absolute URIs are URIs that start with a ",(0,n.jsx)(a.code,{children:"/"}),", relative URIs do not. A relative URI may simply start with a ViewName, or it may start with ",(0,n.jsx)(a.code,{children:"../"})," to go back a level."]}),"\n",(0,n.jsx)(a.p,{children:"When navigating with an Absolute URI, the Navigation Service will set a new Page on the Application Window. When navigating with a Relative URI, the Navigation Service will push a new Page onto the Navigation Stack."}),"\n",(0,n.jsxs)(a.p,{children:["Better yet when using the shorthand syntax ",(0,n.jsx)(a.code,{children:"../"})," you can use this to both Navigate Back and Navigate Forward at the same time. Conceptually you might consider the example where your current Navigation Stack looks like ",(0,n.jsx)(a.code,{children:"NavigationPage/ViewA/ViewB"})," and you are navigating from the ViewBViewModel. You can pass instead of first calling GoBack and then having to navigate forward again, you can instead pass a URI like ",(0,n.jsx)(a.code,{children:"../ViewC"})," and the Navigation Service will pop ViewB from the NavigationPage and push ViewC onto the NavigationStack."]}),"\n",(0,n.jsx)(a.h3,{id:"gobackasync",children:"GoBackAsync"}),"\n",(0,n.jsx)(a.h3,{id:"gobacktorootasync",children:"GoBackToRootAsync"})]})}function c(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,a,t)=>{t.d(a,{R:()=>s,x:()=>r});var i=t(6540);const n={},o=i.createContext(n);function s(e){const a=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),i.createElement(o.Provider,{value:a},e.children)}}}]);