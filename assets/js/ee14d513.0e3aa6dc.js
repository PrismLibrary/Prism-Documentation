"use strict";(globalThis.webpackChunkprism_docs=globalThis.webpackChunkprism_docs||[]).push([[6367],{844:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/Ch7UIFig11-0c037f42b656b8ee9d456e61a2777134.png"},3728:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/Ch7UIFig8-15cfdc0cbf491bb36dd4b62882391558.png"},3733:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/Ch7UIFig10-25753c4d207a49ffce88ce2091519b81.png"},3918:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/Ch7UIFig6-db39472ef89aa7086db1fd07f6ca071e.png"},5833:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/Ch7UIFig9-33c8c38ac9ceb3fc592b13e5bfe1d7fd.png"},7009:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/Ch7UIFig1-48948a79d37ebcfa53390d39de428dcc.png"},7899:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"platforms/wpf/view-composition","title":"Composing the User Interface Using the Prism Library for WPF","description":"A composite application user interface (UI) is composed from loosely coupled visual components known as views that are typically contained in the application modules, but they do not need to be. If you divide your application into modules, you need some way to loosely compose the UI, but you might choose to use this approach even if the views are not in modules. To the user, the application presents a seamless user experience and delivers a fully integrated application.","source":"@site/docs/platforms/wpf/view-composition.md","sourceDirName":"platforms/wpf","slug":"/platforms/wpf/view-composition","permalink":"/docs/current/platforms/wpf/view-composition","draft":false,"unlisted":false,"editUrl":"https://github.com/PrismLibrary/Prism-Documentation/edit/master/docs/platforms/wpf/view-composition.md","tags":[],"version":"current","lastUpdatedBy":"Dan Siegel","lastUpdatedAt":1763924367000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Getting Started","permalink":"/docs/current/platforms/wpf/getting-started"},"next":{"title":"Binding Events to Commands","permalink":"/docs/current/platforms/wpf/interactivity/event-to-command"}}');var o=n(4848),a=n(8453);const s={sidebar_position:1},r="Composing the User Interface Using the Prism Library for WPF",l={},h=[{value:"UI Layout Concepts",id:"ui-layout-concepts",level:2},{value:"Shell",id:"shell",level:3},{value:"Views",id:"views",level:3},{value:"Composite Views",id:"composite-views",level:4},{value:"Regions",id:"regions",level:3},{value:"Region Manager",id:"region-manager",level:4},{value:"Region Implementation",id:"region-implementation",level:4},{value:"Module User Control to Region Mapping",id:"module-user-control-to-region-mapping",level:5},{value:"Default Region Functionality",id:"default-region-functionality",level:4},{value:"Region Adapter",id:"region-adapter",level:5},{value:"Region Behaviors",id:"region-behaviors",level:5},{value:"Registration Behavior",id:"registration-behavior",level:5},{value:"Auto-Population Behavior",id:"auto-population-behavior",level:5},{value:"Region Context Behaviors",id:"region-context-behaviors",level:5},{value:"Activation Behavior",id:"activation-behavior",level:5},{value:"Region Lifetime Behavior",id:"region-lifetime-behavior",level:5},{value:"Control-Specific Behaviors",id:"control-specific-behaviors",level:5},{value:"Extending the Region Implementation",id:"extending-the-region-implementation",level:4},{value:"View Composition",id:"view-composition",level:3},{value:"View Discovery",id:"view-discovery",level:4},{value:"View Injection",id:"view-injection",level:4},{value:"Navigation",id:"navigation",level:4},{value:"When to Use View Discovery vs. View Injection",id:"when-to-use-view-discovery-vs-view-injection",level:4},{value:"UI Layout Scenarios",id:"ui-layout-scenarios",level:2},{value:"Implementing the Shell",id:"implementing-the-shell",level:3},{value:"Sample Shell",id:"sample-shell",level:4},{value:"Defining Regions",id:"defining-regions",level:3},{value:"Sample App Shell Regions",id:"sample-app-shell-regions",level:4},{value:"Adding a Region in XAML",id:"adding-a-region-in-xaml",level:4},{value:"Adding a Region by Using Code",id:"adding-a-region-by-using-code",level:4},{value:"Displaying Views in a Region When the Region Loads",id:"displaying-views-in-a-region-when-the-region-loads",level:3},{value:"Displaying Views in a Region Programmatically",id:"displaying-views-in-a-region-programmatically",level:3},{value:"Ordering Views in a Region",id:"ordering-views-in-a-region",level:4},{value:"Sharing Data Between Multiple Regions",id:"sharing-data-between-multiple-regions",level:3},{value:"Creating Multiple Instances of a Region",id:"creating-multiple-instances-of-a-region",level:3}];function d(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"composing-the-user-interface-using-the-prism-library-for-wpf",children:"Composing the User Interface Using the Prism Library for WPF"})}),"\n",(0,o.jsxs)(i.p,{children:["A composite application user interface (UI) is composed from loosely coupled visual components known as ",(0,o.jsx)(i.strong,{children:"views"})," that are typically contained in the application modules, but they do not need to be. If you divide your application into modules, you need some way to loosely compose the UI, but you might choose to use this approach even if the views are not in modules. To the user, the application presents a seamless user experience and delivers a fully integrated application."]}),"\n",(0,o.jsx)(i.p,{children:"To compose your UI, you need an architecture that allows you to create a layout composed of loosely coupled visual elements generated at run time. Additionally, the architecture should provide strategies for these visual elements to communicate in a loosely coupled fashion."}),"\n",(0,o.jsx)(i.p,{children:"An application UI can be built by using one of the following paradigms:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["All required controls for a form are contained in a single Extensible Application Markup Language (",(0,o.jsx)(i.strong,{children:"XAML"}),") file, composing the form at design time."]}),"\n",(0,o.jsx)(i.li,{children:"Logical areas of the form are separated into distinct parts, typically user controls. The parts are referenced by the form, and the form is composed at design time."}),"\n",(0,o.jsx)(i.li,{children:"Logical areas of the form are separated into distinct parts, typically user controls. The parts are unknown to the form and are dynamically added to the form at run time. Applications that use this methodology are known as composite applications using UI composition patterns."}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Below is a picture of an app. It is composed by loading multiple views that come from different modules into regions exposed by the shell, as shown in the following illustration."}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"Sample app with regions and views",src:n(7009).A+"",width:"600",height:"453"})}),"\n",(0,o.jsx)(i.h2,{id:"ui-layout-concepts",children:"UI Layout Concepts"}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"shell"})," is typically the main application window and it is comprised of regions. Regions are mostly contained within ",(0,o.jsx)(i.code,{children:"ContentControl"}),"'s, ",(0,o.jsx)(i.code,{children:"ItemControl"}),"'s and ",(0,o.jsx)(i.code,{children:"TabControl"}),"'s, and the shell has no knowledge of what is implemented in the ",(0,o.jsx)(i.code,{children:"region"}),". Inside the ",(0,o.jsx)(i.code,{children:"region"})," are views. The view is the implementation of a specific portion of the UI and is decoupled from other parts of the application."]}),"\n",(0,o.jsx)(i.p,{children:"The following sections introduce the high-level core concepts for composite application development."}),"\n",(0,o.jsx)(i.h3,{id:"shell",children:"Shell"}),"\n",(0,o.jsxs)(i.p,{children:["The shell is the application root object that contains the primary UI content. In a Windows Presentation Foundation (WPF) application, the shell is the ",(0,o.jsx)(i.code,{children:"Window"})," object."]}),"\n",(0,o.jsx)(i.p,{children:"The shell plays the role of a master page providing the layout structure for the application. The shell contains one or more named regions where modules can specify the views that will appear. It can also define certain top-level UI elements, such as the background, main menu, and toolbar."}),"\n",(0,o.jsx)(i.p,{children:"The shell defines the overall appearance of the application. It might define styles and borders that are present and visible in the shell layout itself, and it might also define styles, templates, and themes that will be applied to the views that are plugged into the shell."}),"\n",(0,o.jsx)(i.p,{children:"Typically, the shell is a part of the WPF application project. The assembly that contains the shell might or might not reference the assemblies that contain the views to be loaded in the shell's regions."}),"\n",(0,o.jsx)(i.h3,{id:"views",children:"Views"}),"\n",(0,o.jsx)(i.p,{children:"Views are the main unit of UI construction within a composite application. You can define a view as a user control, page, data template, or custom control. A view encapsulates a portion of your UI that you would like to keep as decoupled as possible from other parts of the application. You can choose what goes in a view based on encapsulation or a piece of functionality, or you can choose to define something as a view because you will have multiple instances of that view in your application."}),"\n",(0,o.jsx)(i.p,{children:"Because of the content model of WPF, there is nothing specific to the Prism Library required to define a view. The easiest way to define a view is to define a user control. To add a view to the UI, you simply need a way to construct it and add it to a container. WPF provides mechanisms to do this. The Prism Library adds the ability to define a region into which a view can be dynamically added at run time."}),"\n",(0,o.jsx)(i.h4,{id:"composite-views",children:"Composite Views"}),"\n",(0,o.jsx)(i.p,{children:"A view that supports specific functionality can become complicated. In that case, you might want to divide the view into several child views and have the parent view handle constructing itself by using the child views as parts. The application might do this statically at design time, or it might support having modules add child views through a contained region at run time. When you have a view that is not fully defined in a single view class, you can refer to that as a composite view. In many situations, a composite view is responsible for constructing the child views and for coordinating the interactions between them. You can design child views that are more loosely coupled from their sibling views and their parent composite view by using the Prism Library commands and the event aggregator."}),"\n",(0,o.jsx)(i.h3,{id:"regions",children:"Regions"}),"\n",(0,o.jsx)(i.p,{children:"Regions are enabled in the Prism Library through a region manager, regions, and region adapters."}),"\n",(0,o.jsx)(i.h4,{id:"region-manager",children:"Region Manager"}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"RegionManager"})," class is responsible for creating and maintaining a collection of regions for the host controls. The ",(0,o.jsx)(i.code,{children:"RegionManager"})," uses a control-specific adapter that associates a new region with the host control. The following illustration shows the relationship between the region, control, and adapter set up by the ",(0,o.jsx)(i.code,{children:"RegionManager"}),"."]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"Region, control, and adapter relationship",src:n(8026).A+"",width:"600",height:"311"})}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"RegionManager"})," can create regions in code or in XAML. The ",(0,o.jsx)(i.code,{children:"RegionManager.RegionName"})," attached property is used to create a region in XAML by applying the attached property to the host control."]}),"\n",(0,o.jsxs)(i.p,{children:["Applications can contain one or more instances of a ",(0,o.jsx)(i.code,{children:"RegionManager"}),". You can specify the ",(0,o.jsx)(i.code,{children:"RegionManager"})," instance into which you want to register the region. This is useful if you want to move the control around in the visual tree and do not want the region to be cleared when the attached property value is removed."]}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"RegionManager"})," provides a RegionContext attached property that permits its regions to share data."]}),"\n",(0,o.jsx)(i.h4,{id:"region-implementation",children:"Region Implementation"}),"\n",(0,o.jsxs)(i.p,{children:["A region is a class that implements the ",(0,o.jsx)(i.code,{children:"IRegion"})," interface. The term ",(0,o.jsx)(i.em,{children:"region"})," represents a container that can hold dynamic data that is presented in a UI. A region allows the Prism Library to place dynamic content contained in modules in predefined placeholders in a UI container."]}),"\n",(0,o.jsx)(i.p,{children:"Regions can hold any type of UI content. A module can contain UI content presented as a user control, a data type that is associated with a data template, a custom control, or any combination of these. This lets you define the appearance for the UI areas and then have modules place content in these predetermined areas."}),"\n",(0,o.jsxs)(i.p,{children:["A region can contain zero or more items. Depending on the type of host control the region is managing, one or more of the items could be visible. For example, a ",(0,o.jsx)(i.code,{children:"ContentControl"})," can display only a single object. However, the region in which it is located can contain many items, and an ",(0,o.jsx)(i.code,{children:"ItemsControl"})," can display multiple items. This allows each item in the region to be visible in the UI."]}),"\n",(0,o.jsxs)(i.p,{children:["In the following illustration, the sample app shell contains four regions: ",(0,o.jsx)(i.strong,{children:"MainRegion"}),", ",(0,o.jsx)(i.strong,{children:"MainToolbarRegion"}),", ",(0,o.jsx)(i.strong,{children:"ResearchRegion"}),", and ",(0,o.jsx)(i.strong,{children:"ActionRegion"}),". These regions are populated by the various modules in the application\u2014the content can be changed at any time."]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"Sample app regions",src:n(8787).A+"",width:"600",height:"453"})}),"\n",(0,o.jsx)(i.h5,{id:"module-user-control-to-region-mapping",children:"Module User Control to Region Mapping"}),"\n",(0,o.jsxs)(i.p,{children:["To demonstrate how modules and content are associated with regions, see the following illustration. It shows the association of ",(0,o.jsx)(i.code,{children:"WatchModule"})," and the ",(0,o.jsx)(i.code,{children:"NewsModule"})," with the corresponding regions in the shell."]}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.strong,{children:"MainRegion"})," contains the ",(0,o.jsx)(i.code,{children:"WatchListView"})," user control, which is contained in the ",(0,o.jsx)(i.code,{children:"WatchModule"}),". The ",(0,o.jsx)(i.strong,{children:"ResearchRegion"})," also contains the ",(0,o.jsx)(i.code,{children:"ArticleView"})," user control, which is contained in the ",(0,o.jsx)(i.code,{children:"NewsModule"}),"."]}),"\n",(0,o.jsx)(i.p,{children:"In applications created with the Prism Library, mappings like this will be a part of the design process because designers and developers use them to determine what content is proposed to be in a specific region. This allows designers to determine the overall space needed and any additional items that must be added to ensure that the content will be viewable in the allowable space."}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"Module user control to region mapping",src:n(8828).A+"",width:"600",height:"350"})}),"\n",(0,o.jsx)(i.h4,{id:"default-region-functionality",children:"Default Region Functionality"}),"\n",(0,o.jsx)(i.p,{children:"While you do not need to fully understand region implementations to use them, it might be useful to understand how controls and regions are associated and the default region functionality: for example, how a region locates and instantiates views, how views can be notified when they are the active view, or how view lifetime can be tied to activation."}),"\n",(0,o.jsx)(i.p,{children:"The following sections describe the region adapter and region behaviors."}),"\n",(0,o.jsx)(i.h5,{id:"region-adapter",children:"Region Adapter"}),"\n",(0,o.jsxs)(i.p,{children:["To expose a UI control as a region, it must have a region adapter. Region adapters are responsible for creating a region and associating it with the control. This allows you to use the ",(0,o.jsx)(i.code,{children:"IRegion"})," interface to manage the UI control contents in a consistent way. Each region adapter adapts a specific type of UI control. The Prism Library provides the following three region adapters:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"ContentControlRegionAdapter"}),". This adapter adapts controls of type ",(0,o.jsx)(i.code,{children:"System.Windows.Controls.ContentControl"})," and derived classes."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"SelectorRegionAdapter"}),". This adapter adapts controls derived from the class ",(0,o.jsx)(i.code,{children:"System.Windows.Controls.Primitives.Selector"}),", such as the ",(0,o.jsx)(i.code,{children:"System.Windows.Controls.TabControl"})," control."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"ItemsControlRegionAdapter"}),". This adapter adapts controls of type ",(0,o.jsx)(i.code,{children:"System.Windows.Controls.ItemsControl"})," and derived classes."]}),"\n"]}),"\n",(0,o.jsx)(i.h5,{id:"region-behaviors",children:"Region Behaviors"}),"\n",(0,o.jsx)(i.p,{children:"The Prism Library introduces the concept of region behaviors. These are pluggable components that give a region most of its functionality. Region behaviors were introduced to support view discovery and region context (described later in this topic). Additionally, behaviors provide an effective way to extend a region's implementation."}),"\n",(0,o.jsxs)(i.p,{children:["A region behavior is a class that is attached to a region to give the region additional functionality. This behavior is attached to the region and remains active for the lifetime of the region. For example, when an ",(0,o.jsx)(i.code,{children:"AutoPopulateRegionBehavior"})," is attached to a region, it automatically instantiates and adds any ",(0,o.jsx)(i.code,{children:"ViewTypes"})," that are registered against regions with that name. For the lifetime of the region, it keeps monitoring the ",(0,o.jsx)(i.code,{children:"RegionViewRegistry"})," for new registrations. It is easy to add custom region behaviors or replace existing behaviors, either on a system-wide or a per-region basis."]}),"\n",(0,o.jsxs)(i.p,{children:["The next sections describe the default behaviors that are automatically added to all regions. One behavior, the ",(0,o.jsx)(i.code,{children:"SelectorItemsSourceSyncBehavior"}),", is only attached to controls that derive from the ",(0,o.jsx)(i.code,{children:"Selector"}),"."]}),"\n",(0,o.jsx)(i.h5,{id:"registration-behavior",children:"Registration Behavior"}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"RegionManagerRegistrationBehavior"})," is responsible for making sure that the region is registered to the correct ",(0,o.jsx)(i.code,{children:"RegionManager"}),". When a view or control is added to the visual tree as a child of another control or region, any region defined in the control should be registered in the ",(0,o.jsx)(i.code,{children:"RegionManager"})," of the parent control. When the child control is removed, the registered region is unregistered."]}),"\n",(0,o.jsx)(i.h5,{id:"auto-population-behavior",children:"Auto-Population Behavior"}),"\n",(0,o.jsxs)(i.p,{children:["There are two classes responsible for implementing view discovery. One of them is the ",(0,o.jsx)(i.code,{children:"AutoPopulateRegionBehavior"}),". When it is attached to a region, it retrieves all view types that are registered under the name of the region. It then creates instances of those views and adds them to the region. After the region is created, the ",(0,o.jsx)(i.code,{children:"AutoPopulateRegionBehavior"})," monitors the ",(0,o.jsx)(i.code,{children:"RegionViewRegistry"})," for any newly registered view types for that region name."]}),"\n",(0,o.jsxs)(i.p,{children:["If you want to have more control over the view discovery process, consider creating your own implementation of the ",(0,o.jsx)(i.code,{children:"IRegionViewRegistry"})," and the ",(0,o.jsx)(i.code,{children:"AutoPopulateRegionBehavior"}),"."]}),"\n",(0,o.jsx)(i.h5,{id:"region-context-behaviors",children:"Region Context Behaviors"}),"\n",(0,o.jsxs)(i.p,{children:["The region context functionality is contained within two behaviors: the ",(0,o.jsx)(i.code,{children:"SyncRegionContextWithHostBehavior"})," and the ",(0,o.jsx)(i.code,{children:"BindRegionContextToDependencyObjectBehavior"}),". These behaviors are responsible for monitoring changes to the context that were made on the region, and then synchronizing the context with a context dependency property attached to the view."]}),"\n",(0,o.jsx)(i.h5,{id:"activation-behavior",children:"Activation Behavior"}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"RegionActiveAwareBehavior"})," is responsible for notifying a view if it is active or inactive. The view must implement ",(0,o.jsx)(i.code,{children:"IActiveAware"})," to receive these change notifications. This active aware notification is one-directional (it travels from the behavior to the view). The view cannot affect its active state by changing the active property on the ",(0,o.jsx)(i.code,{children:"IActiveAware"})," interface."]}),"\n",(0,o.jsx)(i.h5,{id:"region-lifetime-behavior",children:"Region Lifetime Behavior"}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"RegionMemberLifetimeBehavior"})," is responsible for determining if an item should be removed from the region when it is deactivated. The ",(0,o.jsx)(i.code,{children:"RegionMemberLifetimeBehavior"})," monitors the region's ",(0,o.jsx)(i.code,{children:"ActiveViews"})," collection to discover items that transition into a deactivated state. The behavior checks the removed items for ",(0,o.jsx)(i.code,{children:"IRegionMemberLifetime"})," or the ",(0,o.jsx)(i.code,{children:"RegionMemberLifetimeAttribute"})," (in that order) to determine if it should be kept alive on removal."]}),"\n",(0,o.jsxs)(i.p,{children:["If the item in the collection is a ",(0,o.jsx)(i.code,{children:"System.Windows.FrameworkElement"}),", it will also check its ",(0,o.jsx)(i.code,{children:"DataContext"})," for ",(0,o.jsx)(i.code,{children:"IRegionMemberLifetime"})," or the ",(0,o.jsx)(i.code,{children:"RegionMemberLifetimeAttribute"}),"."]}),"\n",(0,o.jsx)(i.p,{children:"The region items are checked in the following order:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"IRegionMemberLifetime.KeepAlive"})," value"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"DataContext"}),"'s ",(0,o.jsx)(i.code,{children:"IRegionMemberLifetime.KeepAlive"})," value"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"RegionMemberLifetimeAttribute.KeepAlive"})," value"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"DataContext"}),"'s ",(0,o.jsx)(i.code,{children:"RegionMemberLifetimeAttribute.KeepAlive"})," value"]}),"\n"]}),"\n",(0,o.jsx)(i.h5,{id:"control-specific-behaviors",children:"Control-Specific Behaviors"}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"SelectorItemsSourceSyncBehavior"})," is used only for controls that derive from ",(0,o.jsx)(i.code,{children:"Selector"}),", such as a tab control in WPF. It is responsible for synchronizing the views in the region with the items of the selector, and then synchronizing the active views in the region with the selected items of the selector."]}),"\n",(0,o.jsx)(i.h4,{id:"extending-the-region-implementation",children:"Extending the Region Implementation"}),"\n",(0,o.jsx)(i.p,{children:"The Prism Library provides extension points that allow you to customize or extend the default behavior of the provided APIs. For example, you can write your own region adapters, region behaviors, or change the way the Navigation API parses URIs."}),"\n",(0,o.jsx)(i.h3,{id:"view-composition",children:"View Composition"}),"\n",(0,o.jsx)(i.p,{children:"View composition is the constructing of a view. In composite applications, views from multiple modules have to be displayed at run time in specific locations within the application UI. To achieve this, you need to define the locations where the views will appear and how the views will be created and displayed in those locations."}),"\n",(0,o.jsx)(i.p,{children:"Views can be created and displayed in the locations either automatically through view discovery, or programmatically through view injection. These two techniques determine how individual views are mapped to named locations within the application UI."}),"\n",(0,o.jsx)(i.h4,{id:"view-discovery",children:"View Discovery"}),"\n",(0,o.jsxs)(i.p,{children:["In view discovery, you set up a relationship in the ",(0,o.jsx)(i.code,{children:"RegionViewRegistry"})," between a region's name and the type of a view. When a region is created, the region looks for all the ",(0,o.jsx)(i.code,{children:"ViewTypes"})," associated with the region and automatically instantiates and loads the corresponding views. Therefore, with view discovery, you do not have explicit control over when the views that correspond to a region are loaded and displayed."]}),"\n",(0,o.jsx)(i.h4,{id:"view-injection",children:"View Injection"}),"\n",(0,o.jsxs)(i.p,{children:["In view injection, your code obtains a reference to a region, and then programmatically adds a view into it. Typically, this is done when a module initializes or as a result of a user action. Your code will query a ",(0,o.jsx)(i.code,{children:"RegionManager"})," for a specific region by name and then inject views into it. With view injection, you have more control over when views are loaded and displayed. You also have the ability to remove views from the region. However, with view injection, you cannot add a view to a region that has not yet been created."]}),"\n",(0,o.jsx)(i.h4,{id:"navigation",children:"Navigation"}),"\n",(0,o.jsxs)(i.p,{children:["The Prism Library 8 contains Navigation APIs. The Navigation APIs simplify the view injection process by allowing you to navigate a region to an URI. The Navigation API instantiates the view, adds it to the region, and then activates it. Additionally, the Navigation API allows navigating back to a previously created view contained in a region. For more information about the Navigation APIs, see ",(0,o.jsx)(i.a,{href:"/docs/current/navigation/regions/basic-region-navigation",children:"Basic Region Navigation"}),"."]}),"\n",(0,o.jsx)(i.h4,{id:"when-to-use-view-discovery-vs-view-injection",children:"When to Use View Discovery vs. View Injection"}),"\n",(0,o.jsx)(i.p,{children:"Choosing which view loading strategy to use for a region depends on the application requirements and the function of the region."}),"\n",(0,o.jsx)(i.p,{children:"Use view discovery in the following situations:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Automatic view loading is desired or required."}),"\n",(0,o.jsx)(i.li,{children:"Single instances of a view will be loaded into the region."}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Use view injection in the following situations:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Your application uses the Navigation APIs."}),"\n",(0,o.jsx)(i.li,{children:"You need explicit or programmatic control over when a view is created and displayed, or you need to remove a view from a region; for example, as a result of application logic or navigation."}),"\n",(0,o.jsx)(i.li,{children:"You need to display multiple instances of the same views in a region, where each view instance is bound to different data."}),"\n",(0,o.jsx)(i.li,{children:"You need to control which instance of a region a view is added to. For example, you want to add a customer detail view to a specific customer detail region. (This scenario requires implementing scoped regions as described later in this topic.)"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"ui-layout-scenarios",children:"UI Layout Scenarios"}),"\n",(0,o.jsx)(i.p,{children:"In composite applications, views from multiple modules are displayed at run time in specific locations within the application UI. To achieve this, you need to define the locations where the views will appear and how the views will be created and displayed in those locations."}),"\n",(0,o.jsx)(i.p,{children:"The decoupling of the view and the location in the UI in which it will be displayed allows the appearance and layout of the application to evolve independently of the views that appear within the region."}),"\n",(0,o.jsx)(i.p,{children:"The next sections describe the core scenarios you will encounter when you develop a composite application."}),"\n",(0,o.jsx)(i.h3,{id:"implementing-the-shell",children:"Implementing the Shell"}),"\n",(0,o.jsxs)(i.p,{children:["The shell is the application root object in which the primary UI content is contained. In a WPF application, the shell is the ",(0,o.jsx)(i.code,{children:"Window"})," object."]}),"\n",(0,o.jsx)(i.p,{children:"A shell can contain named regions where modules can specify the views that will appear. It can also define certain top-level UI elements, such as the main menu and toolbar. The shell defines the overall structure and appearance for the application, and is similar to an ASP.NET master page control. It could define styles and borders that are present and visible in the shell layout itself, and it could also define styles, templates, and themes that are applied to the views that are plugged into the shell."}),"\n",(0,o.jsx)(i.p,{children:"You do not need to have a distinct shell as part of your application architecture to use the Prism Library. If you are building a completely new composite application, implementing a shell provides a well-defined root and initialization pattern for setting up the main UI of your application. However, if you are adding Prism Library features to an existing application, you do not have to change the basic architecture of your application to add a shell. Instead, you can alter your existing window definitions or controls to add regions that can pull in views as needed."}),"\n",(0,o.jsx)(i.p,{children:"You can also have more than one shell in your application. If your application is designed to open more than one top-level window for the user, each top-level window acts as shell for the content it contains."}),"\n",(0,o.jsx)(i.h4,{id:"sample-shell",children:"Sample Shell"}),"\n",(0,o.jsx)(i.p,{children:"This sample has a shell as its main window. In the following illustration, the shell and views are highlighted. The shell is the main window that appears when the app starts and which contains all the views. It defines the regions into which modules add their views and a couple of top-level UI items, including the title and the Watch List tear-off banner."}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"Sample shell window, regions, and views",src:n(7009).A+"",width:"600",height:"453"})}),"\n",(0,o.jsx)(i.p,{children:"The shell implementation in the app is provided by Shell.xaml, its code-behind file Shell.xaml.cs, and its view model ShellViewModel.cs. Shell.xaml includes the layout and UI elements that are part of the shell, including definitions of regions to which modules add their views."}),"\n",(0,o.jsxs)(i.p,{children:["The following XAML shows the structure and main XAML elements that define the shell. Notice that the ",(0,o.jsx)(i.code,{children:"RegionName"})," attached property is used to define the four regions and that the window background image provides a background for the shell."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'\x3c!--Shell.xaml (WPF) --\x3e\n<Window x:Class="StockTraderRI.Shell">\n\n    \x3c!--shell background --\x3e\n    <Window.Background>\n        <ImageBrush ImageSource="Resources/background.png" Stretch="UniformToFill"/>\n    </Window.Background>\n\n    <Grid>\n\n        \x3c!-- logo --\x3e\n        <Canvas x:Name="Logo" ...>\n            <TextBlock Text="CFI" ... />\n            <TextBlock Text="STOCKTRADER" .../>\n        </Canvas>\n\n        \x3c!-- main bar --\x3e\n        <ItemsControl \n            x:Name="MainToolbar"\n            prism:RegionManager.RegionName="{x:Static inf:RegionNames.MainToolBarRegion}"/>\n\n        \x3c!-- content --\x3e\n        <Grid>\n            <Controls:AnimatedTabControl\n                x:Name="PositionBuySellTab"\n                prism:RegionManager.RegionName="{x:Static inf:RegionNames.MainRegion}"/>\n        </Grid>\n\n        \x3c!-- details --\x3e\n        <Grid>\n            <ContentControl\n                x:Name="ActionContent"\n                prism:RegionManager.RegionName="{x:Static inf:RegionNames.ActionRegion}"/>\n        </Grid>\n\n        \x3c!-- sidebar --\x3e\n        <Grid x:Name="SideGrid">\n            <Controls:ResearchControl\n                prism:RegionManager.RegionName="{x:Static inf:RegionNames.ResearchRegion}" />\n        </Grid>\n\n    </Grid>\n</Window>\n'})}),"\n",(0,o.jsxs)(i.p,{children:["The implementation of the ",(0,o.jsx)(i.code,{children:"Shell"})," code-behind file is very simple. The ",(0,o.jsx)(i.code,{children:"Shell"})," is exported so that when your ",(0,o.jsx)(i.code,{children:"App"})," object creates it, its dependencies will be added."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cs",children:"// Shell.xaml.cs\n[Export]\npublic partial class Shell : Window\n{\n    public Shell()\n    {\n        InitializeComponent();\n    }\n}\n"})}),"\n",(0,o.jsx)(i.p,{children:"The minimal code in the code-behind file illustrates the power and simplicity of the composite application architecture and loose coupling between the shell and its constituent views."}),"\n",(0,o.jsx)(i.h3,{id:"defining-regions",children:"Defining Regions"}),"\n",(0,o.jsx)(i.p,{children:"You define where views will appear by defining a layout with named locations, known as regions. Regions act as placeholders for one or more views that will be displayed at run time. Modules can locate and add content to regions in the layout without knowing how and where the region is displayed. This allows the layout to change without affecting the modules that add the content to the layout."}),"\n",(0,o.jsx)(i.p,{children:"Regions are defined by assigning a region name to a WPF control, either in XAML as shown in the previous Shell.xaml file or in code. Regions can be accessed by their region name. At run time, views are added to the named Region control, which then displays the view or views according to the layout strategy that the views implement. For example, a tab control region will lay out its child views in a tabbed arrangement. Regions support the addition or removal of views. Views can be created and displayed in regions either programmatically or automatically. In the Prism Library, the former is achieved through view injection and the latter through view discovery. These two techniques determine how individual views are mapped to the named regions within the application UI."}),"\n",(0,o.jsx)(i.p,{children:"The shell of the application defines the application layout at the highest level; for example, by specifying the locations for the main content and the navigation content, as shown in the following illustration. Layout within these high-level views is similarly defined, allowing the overall UI to be recursively composed."}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"A template shell",src:n(3918).A+"",width:"500",height:"356"})}),"\n",(0,o.jsxs)(i.p,{children:["Regions are sometimes used to define locations for multiple views that are logically related. In this scenario, the region control is typically an ",(0,o.jsx)(i.code,{children:"ItemsControl"}),"-derived control that will display the views according to the layout strategy that it implements, such as in a stacked or tabbed layout arrangement."]}),"\n",(0,o.jsxs)(i.p,{children:["Regions can also be used to define a location for a single view; for example, by using a ",(0,o.jsx)(i.code,{children:"ContentControl"}),". In this scenario, the region control displays only one view at a time, even if more than one view is mapped to that region location."]}),"\n",(0,o.jsx)(i.h4,{id:"sample-app-shell-regions",children:"Sample App Shell Regions"}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"Sample app shell regions",src:n(8787).A+"",width:"600",height:"453"})}),"\n",(0,o.jsxs)(i.p,{children:["A multiple-view layout is also demonstrated in the example app ui when the application is buying or selling a stock. The Buy/Sell area is a list-style region that shows multiple buy/sell views (",(0,o.jsx)(i.strong,{children:"OrderCompositeView"}),") as part of its list, as shown in the following illustration."]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"ItemsControl region",src:n(3728).A+"",width:"600",height:"452"})}),"\n",(0,o.jsxs)(i.p,{children:["The shell's ",(0,o.jsx)(i.strong,{children:"ActionRegion"})," contains the ",(0,o.jsx)(i.strong,{children:"OrdersView"}),". The ",(0,o.jsx)(i.strong,{children:"OrdersView"})," contains the ",(0,o.jsx)(i.strong,{children:"Submit All"})," and ",(0,o.jsx)(i.strong,{children:"Cancel All"})," buttons as well as the ",(0,o.jsx)(i.strong,{children:"OrdersRegion"}),". The ",(0,o.jsx)(i.strong,{children:"OrdersRegion"})," is attached to a ",(0,o.jsx)(i.strong,{children:"ListBox"})," control which displays multiple ",(0,o.jsx)(i.strong,{children:"OrderCompositeViews"}),"."]}),"\n",(0,o.jsx)(i.h4,{id:"adding-a-region-in-xaml",children:"Adding a Region in XAML"}),"\n",(0,o.jsxs)(i.p,{children:["A region is a class that implements the ",(0,o.jsx)(i.code,{children:"IRegion"})," interface. The region is the container that holds content to be displayed by a control."]}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"RegionManager"})," supplies an attached property that you can use for simple region creation in XAML. To use the attached property, you must load the Prism Library namespace into the XAML and then use the ",(0,o.jsx)(i.code,{children:"RegionName"})," attached property. The following example shows how to use the attached property in a window with an ",(0,o.jsx)(i.code,{children:"AnimatedTabControl"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Notice the use of the ",(0,o.jsx)(i.code,{children:"x:Static"})," markup extension to reference the ",(0,o.jsx)(i.code,{children:"MainRegion"})," string constant. This practice eliminates magic strings in the XAML."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'\x3c!-- (WPF) --\x3e\n<Controls:AnimatedTabControl \n    x:Name="PositionBuySellTab"\n    prism:RegionManager.RegionName="{x:Static inf:RegionNames.MainRegion}"/>\n'})}),"\n",(0,o.jsx)(i.h4,{id:"adding-a-region-by-using-code",children:"Adding a Region by Using Code"}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"RegionManager"})," can register regions directly without using XAML. The following code example shows how to add a region to a control from the code-behind file. First a reference to the region manager is obtained. Then, using the ",(0,o.jsx)(i.code,{children:"RegionManager"})," static methods ",(0,o.jsx)(i.code,{children:"SetRegionManager"})," and ",(0,o.jsx)(i.code,{children:"SetRegionName"}),", the region is attached to the UI's ",(0,o.jsx)(i.code,{children:"ActionContent"})," control and then that region is named ",(0,o.jsx)(i.code,{children:"ActionRegion"}),"."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cs",children:'IRegionManager regionManager = ServiceLocator.Current.GetInstance<IRegionManager>();\nRegionManager.SetRegionManager(this.ActionContent, regionManager);\nRegionManager.SetRegionName(this.ActionContent, "ActionRegion");\n'})}),"\n",(0,o.jsx)(i.h3,{id:"displaying-views-in-a-region-when-the-region-loads",children:"Displaying Views in a Region When the Region Loads"}),"\n",(0,o.jsx)(i.p,{children:"With the view discovery approach, modules can register views (view models or presentation models) for a specific named location. When that location is displayed at run time, any views that have been registered for that location will be created and displayed within it automatically."}),"\n",(0,o.jsx)(i.p,{children:"Modules register views with a registry. The parent view queries this registry to discover the views that were registered for a named location. After they are discovered, the parent view places those views on the screen by adding them to the placeholder control."}),"\n",(0,o.jsx)(i.p,{children:"After the application is loaded, the composite view is notified to handle the placement of new views that have been added to the registry."}),"\n",(0,o.jsx)(i.p,{children:"The following illustration shows the view discovery approach."}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"View discovery",src:n(5833).A+"",width:"600",height:"400"})}),"\n",(0,o.jsxs)(i.p,{children:["The Prism Library defines a standard registry, ",(0,o.jsx)(i.code,{children:"RegionViewRegistry"}),", to register views for these named locations."]}),"\n",(0,o.jsx)(i.p,{children:"To show a view in a region, register the view with the region manager, as shown in the following code example. You can directly register a view type with the region, in which case the view will be constructed by the dependency injection container and added to the region when the control hosting the region is loaded."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cs",children:'// View discovery\nthis.regionManager.RegisterViewWithRegion("MainRegion", typeof(EmployeeView));\n'})}),"\n",(0,o.jsx)(i.p,{children:"Optionally, you can provide a delegate that returns the view to be shown, as shown in the next example. The region manager will display the view when the region is created."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cs",children:'// View discovery\nthis.regionManager.RegisterViewWithRegion("MainRegion", () => this.container.Resolve<EmployeeView>());\n'})}),"\n",(0,o.jsx)(i.h3,{id:"displaying-views-in-a-region-programmatically",children:"Displaying Views in a Region Programmatically"}),"\n",(0,o.jsx)(i.p,{children:"In the view injection approach, views are programmatically added or removed from a named location by the modules that manage them. To enable this, the application contains a registry of named locations in the UI. A module can use the registry to look up one of the locations and then programmatically inject views into it. To make sure that locations in the registry can be accessed similarly, each of the named locations adheres to a common interface used to inject the view. The following illustration shows the view injection approach."}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"View injection",src:n(3733).A+"",width:"600",height:"335"})}),"\n",(0,o.jsxs)(i.p,{children:["The Prism Library defines a standard registry, ",(0,o.jsx)(i.code,{children:"RegionManager"}),", and a standard interface, ",(0,o.jsx)(i.code,{children:"IRegion"}),", for access these locations."]}),"\n",(0,o.jsxs)(i.p,{children:["To use view injection to add a view to a region, get the region from the region manager, and then call the ",(0,o.jsx)(i.code,{children:"Add"})," method, as shown in the following code. With view injection, the view is displayed only after the view is added to a region, which can happen when the module is loaded or when a user action completes a predefined action."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cs",children:'// View injection\nIRegion region = regionManager.Regions["MainRegion"];\n\nvar ordersView = container.Resolve<OrdersView>();\nregion.Add(ordersView, "OrdersView");\nregion.Activate(ordersView);\n'})}),"\n",(0,o.jsx)(i.h4,{id:"ordering-views-in-a-region",children:"Ordering Views in a Region"}),"\n",(0,o.jsxs)(i.p,{children:["Whether it uses view discovery or view Injection, an application might need to order how views appear in a ",(0,o.jsx)(i.code,{children:"TabControl"}),", ",(0,o.jsx)(i.code,{children:"ItemsControl"}),", or any other control that displays multiple active views. By default, views appear in the order that they were registered and added into the region."]}),"\n",(0,o.jsx)(i.p,{children:"When a composite application is built, views are often registered from different modules. Declaring dependencies between modules can help alleviate the problem, but when modules and views do not have any real interdependencies, declaring an artificial dependency couples modules unnecessarily."}),"\n",(0,o.jsxs)(i.p,{children:["To allow views to participate in ordering themselves, the Prism Library provides the ",(0,o.jsx)(i.code,{children:"ViewSortHint"})," attribute. This attribute contains a string ",(0,o.jsx)(i.code,{children:"Hint"})," property that allows a view to declare a hint of how it should be ordered in the region."]}),"\n",(0,o.jsxs)(i.p,{children:["When displaying views, the ",(0,o.jsx)(i.code,{children:"Region"})," class uses a default view sorting routine that uses the hint to order the views. This is a simple case-sensitive ordinal sort. Views that have the sort hint attribute are ordered ahead of those without. Also, those without the attribute appear in the order they were added to the region."]}),"\n",(0,o.jsxs)(i.p,{children:["If you want to change how views are ordered, the ",(0,o.jsx)(i.code,{children:"Region"})," class provides a ",(0,o.jsx)(i.code,{children:"SortComparison"})," property that you can set with your own ",(0,o.jsx)(i.code,{children:"Comparison<_object_>"})," delegate method. It is important to note that the ordering of the region's ",(0,o.jsx)(i.code,{children:"Views"})," and ",(0,o.jsx)(i.code,{children:"ActiveViews"})," properties are reflected in the UI because adapters such as the ",(0,o.jsx)(i.code,{children:"ItemsControlRegionAdapter"})," bind directly to these properties. A custom region adapter could implement its own sorting and filter that will override how the region orders views."]}),"\n",(0,o.jsx)(i.h3,{id:"sharing-data-between-multiple-regions",children:"Sharing Data Between Multiple Regions"}),"\n",(0,o.jsxs)(i.p,{children:["The Prism Library provides multiple approaches to communicating between views, depending on your scenario. The region manager provides the ",(0,o.jsx)(i.code,{children:"RegionContext"})," property as one of these approaches."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"RegionContext"})," is useful when you want to share context between a parent view and child views that are hosted in a region. ",(0,o.jsx)(i.code,{children:"RegionContext"})," is an attached property. You set the value of the context on the region control so that it can be made available to all child views that are displayed in that region control. The region context can be any simple or complex object and can be a data-bound value. The ",(0,o.jsx)(i.code,{children:"RegionContext"})," can be used with either view discovery or view injection."]}),"\n",(0,o.jsx)(i.admonition,{type:"note",children:(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"DataContext"})," property in WPF is used to set the local data context for the view. It allows the view to use data binding to communicate with a view model, local presenter, or model. ",(0,o.jsx)(i.code,{children:"RegionContext"})," is used to share context between multiple views and is not local to a single view. It provides a simple mechanism for sharing context between multiple views."]})}),"\n",(0,o.jsxs)(i.p,{children:["The following code shows how the ",(0,o.jsx)(i.code,{children:"RegionContext"})," attached property is used in XAML."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<TabControl AutomationProperties.AutomationId="DetailsTabControl" \n    prism:RegionManager.RegionName="{x:Static local:RegionNames.TabRegion}"\n    prism:RegionManager.RegionContext="{Binding Path=SelectedEmployee.EmployeeId}"\n...>\n'})}),"\n",(0,o.jsxs)(i.p,{children:["You can also set the ",(0,o.jsx)(i.code,{children:"RegionContext"})," in code, as shown in the following example."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cs",children:'RegionManager.Regions["Region1"].Context = employeeId;\n'})}),"\n",(0,o.jsxs)(i.p,{children:["To retrieve the ",(0,o.jsx)(i.code,{children:"RegionContext"})," in a view, the ",(0,o.jsx)(i.code,{children:"GetObservableContext"})," static method of the ",(0,o.jsx)(i.code,{children:"RegionContext"})," class is used. It passes the view as a parameter and then accesses its ",(0,o.jsx)(i.code,{children:"Value"})," property, as shown in the following code example."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cs",children:"private void GetRegionContext()\n{\n    this.Model.EmployeeId = (int)RegionContext.GetObservableContext(this).Value;\n}\n"})}),"\n",(0,o.jsxs)(i.p,{children:["The value of the ",(0,o.jsx)(i.code,{children:"RegionContext"})," can be changed from within a view by simply assigning a new value to its ",(0,o.jsx)(i.code,{children:"Value"})," property. Views can opt to be notified of changes to the ",(0,o.jsx)(i.code,{children:"RegionContext"})," by subscribing to the ",(0,o.jsx)(i.code,{children:"PropertyChanged"})," event on the ",(0,o.jsx)(i.code,{children:"ObservableObject"})," that is returned by the ",(0,o.jsx)(i.code,{children:"GetObservableContext"})," method. This allows multiple views to be kept in synchronization when their ",(0,o.jsx)(i.code,{children:"RegionContext"})," is changed. The following code example demonstrates subscribing to the ",(0,o.jsx)(i.code,{children:"PropertyChanged"})," event."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cs",children:'ObservableObject<object> viewRegionContext = \n                RegionContext.GetObservableContext(this);\nviewRegionContext.PropertyChanged += this.ViewRegionContext_OnPropertyChangedEvent;\n\nprivate void ViewRegionContext_OnPropertyChangedEvent(object sender, \n                    PropertyChangedEventArgs args)\n\n{\n    if (args.PropertyName == "Value")\n    {\n        var context = (ObservableObject<object>) sender;\n        int newValue = (int)context.Value;\n    }\n}\n'})}),"\n",(0,o.jsxs)(i.admonition,{type:"note",children:[(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"RegionContext"})," is set as an attached property on the content object hosted in the region. This means that the content object has to derive from ",(0,o.jsx)(i.code,{children:"DependencyObject"}),". In the preceding example, the view is a visual control, which ultimately derives from ",(0,o.jsx)(i.code,{children:"DependencyObject"}),"."]}),(0,o.jsxs)(i.p,{children:["If you choose to use WPF data templates to define your view, the content object will represent the ",(0,o.jsx)(i.code,{children:"ViewModel"})," or ",(0,o.jsx)(i.code,{children:"PresentationModel"}),". If your view model or presentation model needs to retrieve the ",(0,o.jsx)(i.code,{children:"RegionContext"}),", it will need to derive from the ",(0,o.jsx)(i.code,{children:"DependencyObject"})," base class."]})]}),"\n",(0,o.jsx)(i.h3,{id:"creating-multiple-instances-of-a-region",children:"Creating Multiple Instances of a Region"}),"\n",(0,o.jsxs)(i.p,{children:["Scoped regions are available only with view injection. You should use them if you need a view to have its own instance of a region. Views that define regions with attached properties automatically inherit their parent's ",(0,o.jsx)(i.code,{children:"RegionManager"}),". Usually, this is the global ",(0,o.jsx)(i.code,{children:"RegionManager"})," that is registered in the shell window. If the application creates more than one instance of that view, each instance would attempt to register its region with the parent ",(0,o.jsx)(i.code,{children:"RegionManager"}),". ",(0,o.jsx)(i.code,{children:"RegionManager"})," allows only uniquely named regions; therefore, the second registration would produce an error."]}),"\n",(0,o.jsxs)(i.p,{children:["Instead, use scoped regions so that each view will have its own ",(0,o.jsx)(i.code,{children:"RegionManager"})," and its regions will be registered with that ",(0,o.jsx)(i.code,{children:"RegionManager"})," rather than the parent ",(0,o.jsx)(i.code,{children:"RegionManager"}),", as shown in the following illustration."]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"Parent and scoped RegionManagers",src:n(844).A+"",width:"595",height:"329"})}),"\n",(0,o.jsxs)(i.p,{children:["To create a local ",(0,o.jsx)(i.code,{children:"RegionManager"})," for a view, specify that a new ",(0,o.jsx)(i.code,{children:"RegionManager"})," should be created when you add your view to a region, as illustrated in the following code example."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cs",children:'IRegion detailsRegion = this.regionManager.Regions["DetailsRegion"];\nView view = new View();\nbool createRegionManagerScope = true;\nIRegionManager detailsRegionManager = detailsRegion.Add(view, null, createRegionManagerScope);\n'})}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"Add"})," method will return the new ",(0,o.jsx)(i.code,{children:"RegionManager"})," that the view can retain for further access to the local scope."]})]})}function c(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8026:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/Ch7UIFig2-ef4ee0d2e8256e0407bd9f33f710001d.png"},8453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>r});var t=n(6540);const o={},a=t.createContext(o);function s(e){const i=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:i},e.children)}},8787:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/Ch7UIFig3-c93f3a892e438e0c550d1e1b6a022470.png"},8828:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/Ch7UIFig4-72a2a71d849c13537877ec6672a785f8.png"}}]);