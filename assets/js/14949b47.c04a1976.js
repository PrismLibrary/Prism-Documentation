"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[8541],{159:(e,o,n)=>{n.d(o,{A:()=>i});const i=n.p+"assets/images/ModularityDi-58820523851b888265fef479a866b042.png"},244:(e,o,n)=>{n.d(o,{A:()=>i});const i=n.p+"assets/images/ModularityVertical-60645852a9197a11f14706b407f95928.png"},3323:(e,o,n)=>{n.d(o,{A:()=>i});const i=n.p+"assets/images/ModularityHor-f65563750c626e4cf15b8047746950d5.png"},4677:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"modularity/index","title":"Modular Application Development Using Prism Library","description":"A modular application is an application that is divided into a set of loosely coupled functional units (named modules) that can be integrated into a larger application. A client module encapsulates a portion of the application\'s overall functionality and typically represents a set of related concerns. It can include a collection of related components, such as application features, including user interface and business logic, or pieces of application infrastructure, such as application-level services for logging or authenticating users. Modules are independent of one another but can communicate with each other in a loosely coupled fashion. Using a modular application design makes it easier for you to develop, test, deploy, and maintain your application.","source":"@site/versioned_docs/version-9.0/modularity/index.md","sourceDirName":"modularity","slug":"/modularity/","permalink":"/docs/9.0/modularity/","draft":false,"unlisted":false,"editUrl":"https://github.com/PrismLibrary/Prism-Documentation/edit/master/versioned_docs/version-9.0/modularity/index.md","tags":[],"version":"9.0","lastUpdatedBy":"Dan Siegel","lastUpdatedAt":1763924282000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1,"uid":"Modularity.GettingStarted"},"sidebar":"tutorialSidebar","previous":{"title":"Using the ViewModelLocator","permalink":"/docs/9.0/mvvm/viewmodel-locator"},"next":{"title":"Module Catalog","permalink":"/docs/9.0/modularity/module-catalog"}}');var t=n(4848),l=n(8453);const a={sidebar_position:1,uid:"Modularity.GettingStarted"},s="Modular Application Development Using Prism Library",d={},r=[{value:"Benefits of Building Modular Applications",id:"benefits-of-building-modular-applications",level:2},{value:"Prism&#39;s Support for Modular Application Development",id:"prisms-support-for-modular-application-development",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"IModule: The Building Block of Modular Applications",id:"imodule-the-building-block-of-modular-applications",level:3},{value:"Module Lifecycle",id:"module-lifecycle",level:3},{value:"Module Catalog",id:"module-catalog",level:3},{value:"Controlling When to Load a Module",id:"controlling-when-to-load-a-module",level:3},{value:"Integrate Modules With The Application",id:"integrate-modules-with-the-application",level:3},{value:"Communicate Between Modules",id:"communicate-between-modules",level:3},{value:"Dependency Injection and Modular Applications",id:"dependency-injection-and-modular-applications",level:3},{value:"Key Decisions",id:"key-decisions",level:2},{value:"Partition Your Application into Modules",id:"partition-your-application-into-modules",level:2},{value:"Determine Ratio of Projects to Modules",id:"determine-ratio-of-projects-to-modules",level:3},{value:"Use Dependency Injection for Loose Coupling",id:"use-dependency-injection-for-loose-coupling",level:2},{value:"Core Scenarios",id:"core-scenarios",level:2},{value:"Defining a Module",id:"defining-a-module",level:3},{value:"Registering and Discovering Modules",id:"registering-and-discovering-modules",level:3},{value:"Registering Modules in Code",id:"registering-modules-in-code",level:4},{value:"Registering Modules Using a XAML File",id:"registering-modules-using-a-xaml-file",level:4},{value:"Registering Modules Using a Configuration File",id:"registering-modules-using-a-configuration-file",level:4},{value:"Discovering Modules in a Directory",id:"discovering-modules-in-a-directory",level:4},{value:"Other Modularity Items of Note",id:"other-modularity-items-of-note",level:2},{value:"Requesting On-Demand loading of Module",id:"requesting-on-demand-loading-of-module",level:3},{value:"Detecting When a Module is Loaded",id:"detecting-when-a-module-is-loaded",level:3}];function c(e){const o={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.header,{children:(0,t.jsx)(o.h1,{id:"modular-application-development-using-prism-library",children:"Modular Application Development Using Prism Library"})}),"\n",(0,t.jsx)(o.p,{children:"A modular application is an application that is divided into a set of loosely coupled functional units (named modules) that can be integrated into a larger application. A client module encapsulates a portion of the application's overall functionality and typically represents a set of related concerns. It can include a collection of related components, such as application features, including user interface and business logic, or pieces of application infrastructure, such as application-level services for logging or authenticating users. Modules are independent of one another but can communicate with each other in a loosely coupled fashion. Using a modular application design makes it easier for you to develop, test, deploy, and maintain your application."}),"\n",(0,t.jsx)(o.p,{children:"For example, consider a personal banking application. The user can access a variety of functions, such as transferring money between accounts, paying bills, and updating personal information from a single user interface (UI). However, behind the scenes, each of these functions is encapsulated within a discrete module. These modules communicate with each other and with back-end systems such as database servers and web services. Application services integrate the various components within each of the different modules and handle the communication with the user. The user sees an integrated view that looks like a single application."}),"\n",(0,t.jsx)(o.p,{children:"The following illustration shows a design of a modular application with multiple modules."}),"\n",(0,t.jsx)(o.p,{children:(0,t.jsx)(o.img,{alt:"Module composition",src:n(6616).A+"",width:"600",height:"381"})}),"\n",(0,t.jsx)(o.h2,{id:"benefits-of-building-modular-applications",children:"Benefits of Building Modular Applications"}),"\n",(0,t.jsx)(o.p,{children:'You are probably already building a well-architected application using assemblies, interfaces, and classes, and employing good object-oriented design principles. Even so, unless great care is taken, your application design may still be "monolithic" (where all the functionality is implemented in a tightly coupled way within the application), which can make the application difficult to develop, test, extend, and maintain.'}),"\n",(0,t.jsx)(o.p,{children:"The modular application approach, on the other hand, can help you to identify the large scale functional areas of your application and allow you to develop and test that functionality independently. This can make development and testing easier, but it can also make your application more flexible and easier to extend in the future. The benefit of the modular approach is that it can make your overall application architecture more flexible and maintainable because it allows you to break your application into manageable pieces. Each piece encapsulates specific functionality, and each piece is integrated through clear but loosely coupled communication channels."}),"\n",(0,t.jsx)(o.h2,{id:"prisms-support-for-modular-application-development",children:"Prism's Support for Modular Application Development"}),"\n",(0,t.jsx)(o.p,{children:"Prism provides support for modular application development and for run-time module management within your application. Using Prism's modular development functionality can save you time because you don't have to implement and test your own modularity framework. Prism supports the following modular application development features:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:["A module catalog for registering named modules and each module's location; you can create the module catalog in the following ways:","\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"By defining modules in code or Extensible Application Markup Language (XAML)"}),"\n",(0,t.jsx)(o.li,{children:"By discovering modules in a directory so you can load all your modules without explicitly defining in a centralized catalog"}),"\n",(0,t.jsx)(o.li,{children:"By defining modules in a configuration file"}),"\n",(0,t.jsx)(o.li,{children:"Declarative metadata attributes for modules to support initialization mode and dependencies"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(o.li,{children:["For module loading:","\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"Dependency management, including duplicate and cycle detection to ensure modules are loaded in the correct order and only loaded and initialized once"}),"\n",(0,t.jsx)(o.li,{children:"On-demand and background downloading of modules to minimize application start-up time; the rest of the modules can be loaded and initialized in the background or when they are required"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(o.li,{children:"Integration with dependency injection containers to support loose coupling between modules"}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsxs)(o.p,{children:["This section introduces the core concepts related to modularity in Prism, including the ",(0,t.jsx)(o.code,{children:"IModule"})," interface, the module loading process, the module catalog, communicating between modules, and dependency injection containers."]}),"\n",(0,t.jsx)(o.h3,{id:"imodule-the-building-block-of-modular-applications",children:"IModule: The Building Block of Modular Applications"}),"\n",(0,t.jsxs)(o.p,{children:["A module is a logical collection of functionality and resources that is packaged in a way that can be separately developed, tested, deployed, and integrated into an application. A package can be one or more assemblies. Each module has a central class that is responsible for initializing the module and integrating its functionality into the application. That class implements the ",(0,t.jsx)(o.code,{children:"IModule"})," interface."]}),"\n",(0,t.jsx)(o.p,{children:(0,t.jsxs)(o.em,{children:[(0,t.jsx)(o.strong,{children:"Note:"})," The presence of a class that implements the ",(0,t.jsx)(o.code,{children:"IModule"})," interface is enough to identify the package as a module."]})}),"\n",(0,t.jsxs)(o.p,{children:["The ",(0,t.jsx)(o.code,{children:"IModule"})," interface has two methods, named ",(0,t.jsx)(o.code,{children:"OnInitialized"})," and ",(0,t.jsx)(o.code,{children:"RegisterTypes"}),". Both take a reference to the dependency injection container as a parameter. When a module is loaded into the application, ",(0,t.jsx)(o.code,{children:"RegisterTypes"})," is called first and should be used to register any services or functionality that the module implements. Next the ",(0,t.jsx)(o.code,{children:"OnInitialized"})," method is called. It is here that things like view registrations or any other module initialization code should be performed."]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-cs",children:'public class MyModule : IModule\n{\n    public void RegisterTypes(IContainerRegistry containerRegistry)\n    {\n        // register with the container that SomeService implements ISomeService\n        // ISomeService is defined in the Infrastructure module, see app architecture diagram\n        containerRegistry.Register<MyApplication.Infrastructure.ISomeService, SomeService>();\n    }\n\n    public void OnInitialized(IContainerProvider containerProvider)\n    {\n        // use the containerProvider to retrieve the instance of the Prism RegionManager\n        // and register the view in this module with a specific region in the app\n        var regionManager = containerProvider.Resolve<IRegionManager>();\n        regionManager.RegisterViewWithRegion("MyModuleView", typeof(Views.ThisModuleView));\n    }\n}\n'})}),"\n",(0,t.jsx)(o.h3,{id:"module-lifecycle",children:"Module Lifecycle"}),"\n",(0,t.jsx)(o.p,{children:"The module loading process in Prism includes the following sequence:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Registering"})," Modules are created by implementing the IModule interface inside of a class."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Discovering modules"}),". The modules to be loaded at run-time for a particular application are defined in a Module catalog. The catalog contains information about the modules to be loaded, such as their location, and the order in which they are to be loaded."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Loading modules"}),". The assemblies that contain the modules are loaded into memory."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Initializing modules"}),". The modules are then initialized. This means creating instances of the module class and calling the ",(0,t.jsx)(o.code,{children:"RegisterTypes"})," and ",(0,t.jsx)(o.code,{children:"OnInitialized"})," methods on them via the ",(0,t.jsx)(o.code,{children:"IModule"})," interface."]}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"module-catalog",children:"Module Catalog"}),"\n",(0,t.jsxs)(o.p,{children:["The ",(0,t.jsx)(o.code,{children:"ModuleCatalog"})," holds information about the modules that can be used by the application. The catalog is essentially a collection of ",(0,t.jsx)(o.code,{children:"ModuleInfo"})," classes. Each module is described in a ",(0,t.jsx)(o.code,{children:"ModuleInfo"})," class that records the name, type, and location, among other attributes of the module. There are several typical approaches to filling the ",(0,t.jsx)(o.strong,{children:"ModuleCatalog"})," with ",(0,t.jsx)(o.strong,{children:"ModuleInfo"})," instances:"]}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"Registering modules in code"}),"\n",(0,t.jsx)(o.li,{children:"Registering modules in XAML"}),"\n",(0,t.jsx)(o.li,{children:"Registering modules in a configuration file"}),"\n",(0,t.jsx)(o.li,{children:"Discovering modules in a local directory on disk"}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"The registration and discovery mechanism you should use depends on what your application needs. Using a configuration file or XAML file allows your application to not require references to the modules. Using a directory can allow an application to discover modules without having to specify them in a file."}),"\n",(0,t.jsx)(o.h3,{id:"controlling-when-to-load-a-module",children:"Controlling When to Load a Module"}),"\n",(0,t.jsx)(o.p,{children:'Prism applications can initialize modules as soon as possible, known as "when available," or when the application needs them, known as "on-demand." Consider the following guidelines for loading modules:'}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"Modules required for the application to run must be loaded with the application and initialized when the application runs."}),"\n",(0,t.jsx)(o.li,{children:"Modules containing features that are rarely used (or are support modules that other modules optionally depend upon) can be loaded and initialized on-demand."}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"Consider how you are partitioning your application, common usage scenarios and application start-up time for determining how to configure your app for initialization."}),"\n",(0,t.jsx)(o.h3,{id:"integrate-modules-with-the-application",children:"Integrate Modules With The Application"}),"\n",(0,t.jsxs)(o.p,{children:["Each of the ",(0,t.jsx)(o.code,{children:"Prism.DryIoc.[Platform]"})," and ",(0,t.jsx)(o.code,{children:"Prism.Unity.[Platform]"})," assemblies provide an ",(0,t.jsx)(o.code,{children:"Application"})," based class that is used as the base class for the App class. Override the virtual method ",(0,t.jsx)(o.code,{children:"CreateModuleCatalog"})," to create the desired type of module catalog."]}),"\n",(0,t.jsxs)(o.p,{children:["For each of the modules in the app, implement the ",(0,t.jsx)(o.code,{children:"IModuleInfo"})," interface to register module types and services. The following are common things to do to when integrating a module into the app:"]}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"Add the module's views to the application's navigation structure. This is common when building composite UI applications using view discovery or view injection."}),"\n",(0,t.jsx)(o.li,{children:"Subscribe to application level events or services."}),"\n",(0,t.jsx)(o.li,{children:"Register shared services with the application's dependency injection container."}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"communicate-between-modules",children:"Communicate Between Modules"}),"\n",(0,t.jsx)(o.p,{children:"Even though modules should have low coupling between each other, it is common for modules to communicate with each other. There are several loosely coupled communication patterns, each with their own strengths. Typically, combinations of these patterns are used to create the resulting solution. The following are some of these patterns:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Loosely coupled events"}),". A module can broadcast that a certain event has occurred. Other modules can subscribe to those events so they will be notified when the event occurs. Loosely coupled events are a lightweight manner of setting up communication between two modules; therefore, they are easily implemented. However, a design that relies too heavily on events can become hard to maintain, especially if many events have to be orchestrated together to fulfill a single task. In that case, it might be better to consider a shared service."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Shared services"}),". A shared service is a class that can be accessed through a common interface. Typically, shared services are found in a shared assembly and provide system-wide services, such as authentication, logging, or configuration."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Shared resources"}),". If you do not want modules to directly communicate with each other, you can also have them communicate indirectly through a shared resource, such as a database or a set of web services."]}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"dependency-injection-and-modular-applications",children:"Dependency Injection and Modular Applications"}),"\n",(0,t.jsxs)(o.p,{children:["Containers like ",(0,t.jsx)(o.strong,{children:"Unity"})," and ",(0,t.jsx)(o.strong,{children:"DryIoc"})," allow you to easily use Inversion of Control (IoC) and Dependency Injection, which are powerful design patterns that help to compose components in a loosely-coupled fashion. It allows components to obtain references to the other components that they depend on without having to hard code those references, thereby promoting better code re-use and improved flexibility. Dependency injection is very useful when building a loosely coupled, modular application. Prism is designed to be agnostic about the dependency injection container used to compose components within an application."]}),"\n",(0,t.jsx)(o.p,{children:"Regardless of which of the three containers is chosen, Prism will use the container to construct and initialize each of the modules so that they remain loosely coupled."}),"\n",(0,t.jsx)(o.h2,{id:"key-decisions",children:"Key Decisions"}),"\n",(0,t.jsx)(o.p,{children:"The first decision you will make is whether you want to develop a modular solution. There are numerous benefits of building modular applications as discussed in the previous section, but there is a commitment in terms of time and effort that you need to make to reap these benefits. If you decide to develop a modular solution, there are several more things to consider:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Determine the framework you will use"}),". You can create your own modularity framework, use Prism, or another framework."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Determine how to organize your solution"}),". Approach a modular architecture by defining the boundaries of each module, including what assemblies are part of each module. You can decide to use modularity to ease the development, as well as to have control over how the application will be deployed or if it will support a plug-in or extensible architecture."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Determine how to partition your modules"}),". Modules can be partitioned differently based on requirements, for example, by functional areas, provider modules, development teams and deployment requirements."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Determine the core services that the application will provide to all modules"}),". An example is that core services could be an error reporting service or an authentication and authorization service."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"If you are using Prism, determine what approach you are using to register modules in the module catalog"}),". For WPF, you can register modules in code, XAML, in a configuration file, or discovering modules in a local directory on disk."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Determine your module communication and dependency strategy"}),". Modules will need to communicate with each other, and you will need to deal with dependencies between modules."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Determine your dependency injection container"}),". Typically, modular systems require dependency injection, inversion of control, or service locator to allow the loose coupling and dynamic loading and creating of modules. Prism allows a choice between using Unity or DryIoc and provides libraries for Unity and DryIoc based applications."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Minimize application startup time"}),". Think about on-demand and background downloading of modules to minimize application startup time."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Determine deployment requirements"}),". You will need to think about how you intend to deploy your application."]}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"The next sections provide details about some of these decisions."}),"\n",(0,t.jsx)(o.h2,{id:"partition-your-application-into-modules",children:"Partition Your Application into Modules"}),"\n",(0,t.jsx)(o.p,{children:"When you develop your application in a modularized fashion, you structure the application into separate client modules that can be individually developed, tested, and deployed. Each module will encapsulate a portion of your application's overall functionality. One of the first design decisions you will have to make is to decide how to partition your application's functionality into discrete modules."}),"\n",(0,t.jsx)(o.p,{children:"A module should encapsulate a set of related concerns and have a distinct set of responsibilities. A module can represent a vertical slice of the application or a horizontal service layer."}),"\n",(0,t.jsx)(o.p,{children:(0,t.jsx)(o.img,{alt:"A vertical sliced application",src:n(244).A+"",width:"600",height:"286"})}),"\n",(0,t.jsx)(o.p,{children:"An application with modules organized around vertical slices"}),"\n",(0,t.jsx)(o.p,{children:(0,t.jsx)(o.img,{alt:"A horizontal layered application",src:n(3323).A+"",width:"600",height:"287"})}),"\n",(0,t.jsx)(o.p,{children:"An application with modules organized around horizontal layers"}),"\n",(0,t.jsx)(o.p,{children:"A larger application may have modules organized with vertical slices and horizontal layers. Some examples of modules include the following:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"A module that contains a specific application feature, such as a module that serves news and/or announcements"}),"\n",(0,t.jsx)(o.li,{children:"A module that contains a specific sub-system or functionality for a set of related use cases, such as purchasing, invoicing, or general ledger"}),"\n",(0,t.jsx)(o.li,{children:"A module that contains infrastructure services, such as logging, caching, and authorization services, or web services"}),"\n",(0,t.jsx)(o.li,{children:"A module that contains services that invoke line-of-business (LOB) systems, such as Siebel CRM and SAP, in addition to other internal systems"}),"\n"]}),"\n",(0,t.jsxs)(o.p,{children:["A module should have a minimal set of dependencies on other modules. When a module has a dependency on another module, it should be loosely coupled by using interfaces defined in a shared library instead of concrete types, or by using the ",(0,t.jsx)(o.strong,{children:"EventAggregator"})," to communicate with other modules via ",(0,t.jsx)(o.strong,{children:"EventAggregator"})," event types."]}),"\n",(0,t.jsx)(o.p,{children:"The goal of modularity is to partition the application in such a way that it remains flexible, maintainable, and stable even as features and technologies are added and removed. The best way to accomplish this is to design your application so that modules are as independent as possible, have well defined interfaces, and are as isolated as possible."}),"\n",(0,t.jsx)(o.h3,{id:"determine-ratio-of-projects-to-modules",children:"Determine Ratio of Projects to Modules"}),"\n",(0,t.jsx)(o.p,{children:"There are several ways to create and package modules. The recommended and most common way is to create a single assembly per module. This helps keep logical modules separate and promotes proper encapsulation. It also makes it easier to talk about the assembly as the module boundary as well as the packaging of how you deploy the module. However, nothing prevents a single assembly from containing multiple modules, and in some cases this may be preferred to minimize the number of projects in your solution. For a large application, it is not uncommon to have 10\u201350 modules. Separating each module into its own project adds a lot of complexity to the solution and can slow down Visual Studio performance. Sometimes it makes sense to break a module or set of modules into their own solution to manage this if you choose to stick to one module per assembly/Visual Studio project."}),"\n",(0,t.jsx)(o.h2,{id:"use-dependency-injection-for-loose-coupling",children:"Use Dependency Injection for Loose Coupling"}),"\n",(0,t.jsx)(o.p,{children:"A module may depend on components and services provided by the host application or by other modules. Prism supports the ability to register dependencies between modules so that they are loaded and initialized in the right order. Prism also supports the initialization of modules when they are loaded into the application. During module initialization, the module can retrieve references to the additional components and services it requires, and/or register any components and services that it contains in order to make them available to other modules."}),"\n",(0,t.jsx)(o.p,{children:"A module should use an independent mechanism to get instances of external interfaces instead of directly instantiating a concrete type, for example by using a dependency injection container or factory service. Dependency injection containers such as Unity or DryIoc allow a type to automatically acquire instances of the interfaces and types it needs through dependency injection. Prism integrates with Unity and DryIoc to allow a module to easily use dependency injection."}),"\n",(0,t.jsx)(o.p,{children:"The following diagram shows the typical sequence of operations when modules are loaded that need to acquire or register references to the components and services."}),"\n",(0,t.jsx)(o.p,{children:(0,t.jsx)(o.img,{alt:"Example of dependency injection",src:n(159).A+"",width:"600",height:"474"})}),"\n",(0,t.jsxs)(o.p,{children:["In this example, the ",(0,t.jsx)(o.code,{children:"OrdersModule"})," assembly defines an ",(0,t.jsx)(o.code,{children:"OrdersRepository"})," class (along with other views and classes that implement order functionality). The ",(0,t.jsx)(o.code,{children:"CustomerModule"})," assembly defines a ",(0,t.jsx)(o.code,{children:"CustomersViewModel"})," class which depends on the ",(0,t.jsx)(o.code,{children:"OrdersRepository"}),", typically based on an interface exposed by the service. The application startup and bootstrapping process contains the following steps:"]}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsxs)(o.li,{children:["The ",(0,t.jsx)(o.code,{children:"App"})," class that is derived from ",(0,t.jsx)(o.code,{children:"PrismApplication"})," starts the module initialization process, and the module loader loads and initializes the ",(0,t.jsx)(o.code,{children:"OrdersModule"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:["In the initialization of the ",(0,t.jsx)(o.code,{children:"OrdersModule"}),", it registers the ",(0,t.jsx)(o.code,{children:"OrdersRepository"})," with the container."]}),"\n",(0,t.jsxs)(o.li,{children:["The module loader then loads the ",(0,t.jsx)(o.code,{children:"CustomersModule"}),". The order of module loading can be specified by the dependencies in the module metadata."]}),"\n",(0,t.jsxs)(o.li,{children:["The ",(0,t.jsx)(o.code,{children:"CustomersModule"})," constructs an instance of the ",(0,t.jsx)(o.code,{children:"CustomerViewModel"})," by resolving it through the container. The ",(0,t.jsx)(o.code,{children:"CustomerViewModel"})," has a dependency on the ",(0,t.jsx)(o.code,{children:"OrdersRepository"})," (typically based on its interface) and indicates it through constructor or property injection. The container injects that dependency in the construction of the view model based on the type registered by the ",(0,t.jsx)(o.code,{children:"OrdersModule"}),". The net result is an interface reference from the ",(0,t.jsx)(o.code,{children:"CustomerViewModel"})," to the ",(0,t.jsx)(o.code,{children:"OrderRepository"})," without tight coupling between those classes."]}),"\n"]}),"\n",(0,t.jsxs)(o.p,{children:[(0,t.jsx)(o.strong,{children:"Note:"})," The interface used to expose the ",(0,t.jsx)(o.code,{children:"OrderRepository"})," (",(0,t.jsx)(o.code,{children:"IOrderRepository"}),') could reside in a separate "shared services" assembly or an "orders services" assembly that only contains the service interfaces and types required to expose those services. This way, there is no hard dependency between the ',(0,t.jsx)(o.code,{children:"CustomersModule"})," and the ",(0,t.jsx)(o.code,{children:"OrdersModule"}),"."]}),"\n",(0,t.jsxs)(o.blockquote,{children:["\n",(0,t.jsx)(o.p,{children:"Note that both modules have an implicit dependency on the dependency injection container. This dependency is injected during module construction in the module loader."}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"core-scenarios",children:"Core Scenarios"}),"\n",(0,t.jsx)(o.p,{children:"This section describes the common scenarios you will encounter when working with modules in your application. These scenarios include defining a module, registering and discovering modules, loading modules, initializing modules, specifying module dependencies, loading modules on demand, downloading remote modules in the background, and detecting when a module has already been loaded. You can register and discover modules in code, in a XAML or application configuration file, or by scanning a local directory."}),"\n",(0,t.jsx)(o.h3,{id:"defining-a-module",children:"Defining a Module"}),"\n",(0,t.jsxs)(o.p,{children:["A module is a logical collection of functionality and resources that is packaged in a way that can be separately developed, tested, deployed, and integrated into an application. Each module has a central class that is responsible for initializing the module and integrating its functionality into the application. That class implements the ",(0,t.jsx)(o.code,{children:"IModule"})," interface, as shown here."]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-cs",children:"public class MyModule : IModule\n{\n    public void RegisterTypes(IContainerRegistry containerRegistry)\n    {\n    }\n\n    public void OnInitialized(IContainerProvider containerProvider)\n    {\n    }\n}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["Implement ",(0,t.jsx)(o.code,{children:"RegisterTypes"})," to handle the registration with the dependency injection container all of the services that this module implements."]}),"\n",(0,t.jsxs)(o.p,{children:["How ",(0,t.jsx)(o.code,{children:"OnInitialized"})," method is implemented will depend on the requirements of your application. Here is where you can register your views and do any other module level initialize that may be required."]}),"\n",(0,t.jsx)(o.h3,{id:"registering-and-discovering-modules",children:"Registering and Discovering Modules"}),"\n",(0,t.jsx)(o.p,{children:"The modules that an application can load are defined in a module catalog. The Prism Module Loader uses the module catalog to determine which modules are available to be loaded into the application, when to load them, and in which order they are to be loaded."}),"\n",(0,t.jsxs)(o.p,{children:["The module catalog is represented by a class that implements the ",(0,t.jsx)(o.code,{children:"IModuleCatalog"})," interface. The module catalog class is created by the ",(0,t.jsx)(o.code,{children:"PrismApplication"})," base class during application initialization. Prism provides different implementations of module catalog for you to choose from. You can also populate a module catalog from another data source by calling the ",(0,t.jsx)(o.code,{children:"AddModule"})," method or by deriving from ",(0,t.jsx)(o.code,{children:"ModuleCatalog"})," to create a module catalog with customized behavior."]}),"\n",(0,t.jsxs)(o.p,{children:["By default, the ",(0,t.jsx)(o.code,{children:"App"})," class, derived from ",(0,t.jsx)(o.code,{children:"PrismApplication"}),", creates a ",(0,t.jsx)(o.code,{children:"ModuleCatalog"})," in the ",(0,t.jsx)(o.code,{children:"CreateModuleCatalog"})," method. In WPF and UNO, you can override this method to use different types of ",(0,t.jsx)(o.code,{children:"ModuleCatalog"}),"."]}),"\n",(0,t.jsx)(o.h4,{id:"registering-modules-in-code",children:"Registering Modules in Code"}),"\n",(0,t.jsxs)(o.p,{children:["The most basic module catalog, and default, is provided by the ",(0,t.jsx)(o.code,{children:"ModuleCatalog"})," class. You can use this module catalog to programmatically register modules by specifying the module class type. You can also programmatically specify the module name and initialization mode. To register the module directly with the ",(0,t.jsx)(o.code,{children:"ModuleCatalog"})," class, call the ",(0,t.jsx)(o.code,{children:"AddModule"})," method in your application's ",(0,t.jsx)(o.code,{children:"PrismApplication"})," derived ",(0,t.jsx)(o.code,{children:"App"})," class. Override ",(0,t.jsx)(o.code,{children:"ConfigureModuleCatalog"})," to add your modules. An example is shown in the following code."]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-cs",children:"protected override void ConfigureModuleCatalog()\n{\n    Type moduleCType = typeof(ModuleC);\n    ModuleCatalog.AddModule(new ModuleInfo()\n    {\n        ModuleName = moduleCType.Name,\n        ModuleType = moduleCType.AssemblyQualifiedName,\n    });\n}\n"})}),"\n",(0,t.jsxs)(o.blockquote,{children:["\n",(0,t.jsxs)(o.p,{children:[(0,t.jsx)(o.strong,{children:"Note:"})," If your application has a direct reference to the module type, you can add it by type as shown above; otherwise you need to provide the fully qualified type name and the location of the assembly."]}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"To specify dependencies in code, use Prism supplied declarative attributes."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-cs",children:'[Module(ModuleName = "ModuleA")]\n[ModuleDependency("ModuleD")]\npublic class ModuleA : IModule\n{\n    ...\n}\n'})}),"\n",(0,t.jsxs)(o.p,{children:["To specify on-demand loading in code, add the ",(0,t.jsx)(o.code,{children:"InitializationMode"})," property to your new instance of ModuleInfo. Using the code below:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-cs",children:"Type moduleCType = typeof(ModuleC);\nModuleCatalog.AddModule(new ModuleInfo()\n{\n    ModuleName = moduleCType.Name,\n    ModuleType = moduleCType.AssemblyQualifiedName,\n    InitializationMode = InitializationMode.OnDemand,\n});\n"})}),"\n",(0,t.jsx)(o.h4,{id:"registering-modules-using-a-xaml-file",children:"Registering Modules Using a XAML File"}),"\n",(0,t.jsxs)(o.p,{children:["You can define a module catalog declaratively by specifying it in a XAML file. The XAML file specifies what kind of module catalog class to create and which modules to add to it. Usually, the .xaml file is added as a resource to your shell project. The module catalog is created by the App with a call to the ",(0,t.jsx)(o.code,{children:"CreateFromXaml"})," method. From a technical perspective, this approach is very similar to defining the ",(0,t.jsx)(o.code,{children:"ModuleCatalog"})," in code because the XAML file simply defines a hierarchy of objects to be instantiated."]}),"\n",(0,t.jsx)(o.p,{children:"The following code example shows a XAML file specifying a module catalog."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-xml",children:'<--! ModulesCatalog.xaml --\x3e\n<Modularity:ModuleCatalog xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"\n    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"\n    xmlns:sys="clr-namespace:System;assembly=mscorlib"\n    xmlns:Modularity="clr-namespace:Microsoft.Practices.Prism.Modularity;assembly=Microsoft.Practices.Prism">\n\n    <Modularity:ModuleInfoGroup Ref="file://DirectoryModules/ModularityWithMef.Desktop.ModuleB.dll" InitializationMode="WhenAvailable">\n        <Modularity:ModuleInfo ModuleName="ModuleB" ModuleType="ModularityWithMef.Desktop.ModuleB, ModularityWithMef.Desktop.ModuleB, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" />\n    </Modularity:ModuleInfoGroup>\n\n    <Modularity:ModuleInfoGroup InitializationMode="OnDemand">\n        <Modularity:ModuleInfo Ref="file://ModularityWithMef.Desktop.ModuleE.dll" ModuleName="ModuleE" ModuleType="ModularityWithMef.Desktop.ModuleE, ModularityWithMef.Desktop.ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" />\n        <Modularity:ModuleInfo Ref="file://ModularityWithMef.Desktop.ModuleF.dll" ModuleName="ModuleF" ModuleType="ModularityWithMef.Desktop.ModuleF, ModularityWithMef.Desktop.ModuleF, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">\n            <Modularity:ModuleInfo.DependsOn>\n                <sys:String>ModuleE</sys:String>\n            </Modularity:ModuleInfo.DependsOn>\n        </Modularity:ModuleInfo>\n    </Modularity:ModuleInfoGroup>\n\n    \x3c!-- Module info without a group --\x3e\n    <Modularity:ModuleInfo Ref="file://DirectoryModules/ModularityWithMef.Desktop.ModuleD.dll" ModuleName="ModuleD" ModuleType="ModularityWithMef.Desktop.ModuleD, ModularityWithMef.Desktop.ModuleD, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" />\n</Modularity:ModuleCatalog>\n'})}),"\n",(0,t.jsxs)(o.blockquote,{children:["\n",(0,t.jsxs)(o.p,{children:[(0,t.jsx)(o.strong,{children:"Note:"})," ",(0,t.jsx)(o.code,{children:"ModuleInfoGroups"})," provide a convenient way to group modules that are in the same assembly, are initialized in the same way, or only have dependencies on modules in the same group. Dependencies between modules can be defined within modules in the same ",(0,t.jsx)(o.code,{children:"ModuleInfoGroup"}),"; however, you cannot define dependencies between modules in different ",(0,t.jsx)(o.code,{children:"ModuleInfoGroups"}),". Putting modules inside module groups is optional. The properties that are set for a group will be applied to all its contained modules. Note that modules can also be registered without being inside a group._"]}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"Example on creating the catalog from a XAML file is below:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-cs",children:'protected override IModuleCatalog CreateModuleCatalog()\n{\n    return ModuleCatalog.CreateFromXaml(new Uri("/MyProject;component/ModulesCatalog.xaml", UriKind.Relative));\n}\n'})}),"\n",(0,t.jsx)(o.p,{children:"To specify dependencies in XAML, follow the example below:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-xml",children:'<-- ModulesCatalog.xaml --\x3e\n<Modularity:ModuleInfo Ref="file://ModuleE.dll" moduleName="ModuleE" moduleType="ModuleE.Module, ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" />\n<Modularity:ModuleInfo Ref="file://ModuleF.dll" moduleName="ModuleF" moduleType="ModuleF.Module, ModuleF, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">\n    <Modularity:ModuleInfo.DependsOn>\n        <sys:String>ModuleE</sys:String>\n    </Modularity:ModuleInfo.DependsOn>\n</Modularity:ModuleInfo>\n'})}),"\n",(0,t.jsxs)(o.p,{children:["To specify on-demand loading of your module, add the ",(0,t.jsx)(o.code,{children:"startupLoaded"})," attribute to the ",(0,t.jsx)(o.code,{children:"Modularity:ModuleInfo"})," element."]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-xml",children:'<Modularity:ModuleInfo Ref="file://ModuleE.dll" moduleName="ModuleE" moduleType="ModuleE.Module, ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" startupLoaded="false" />\n'})}),"\n",(0,t.jsx)(o.h4,{id:"registering-modules-using-a-configuration-file",children:"Registering Modules Using a Configuration File"}),"\n",(0,t.jsx)(o.p,{children:"In WPF, it is possible to specify the module information in the App.config file. The advantage of this approach is that this file is not compiled into the application. This makes it very easy to add or remove modules at run time without recompiling the application."}),"\n",(0,t.jsx)(o.p,{children:"The following code example shows a configuration file specifying a module catalog."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-xml",children:'\x3c!-- ModularityWithUnity.Desktop\\\\app.config --\x3e\n<xml version="1.0" encoding="utf-8" ?>\n<configuration>\n    <configSections>\n        <section name="modules" type="Prism.Modularity.ModulesConfigurationSection, Prism.Wpf"/>\n    </configSections>\n\n    <modules>\n        <module assemblyFile="ModularityWithUnity.Desktop.ModuleE.dll" moduleType="ModularityWithUnity.Desktop.ModuleE, ModularityWithUnity.Desktop.ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" moduleName="ModuleE" startupLoaded="false" />\n        <module assemblyFile="ModularityWithUnity.Desktop.ModuleF.dll" moduleType="ModularityWithUnity.Desktop.ModuleF, ModularityWithUnity.Desktop.ModuleF, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" moduleName="ModuleF" startupLoaded="false">\n            <dependencies>\n                <dependency moduleName="ModuleE"/>\n            </dependencies>\n        </module>\n    </modules>\n</configuration>\n'})}),"\n",(0,t.jsxs)(o.blockquote,{children:["\n",(0,t.jsxs)(o.p,{children:[(0,t.jsx)(o.strong,{children:"Note:"})," Even if your assemblies are in the global assembly cache or in the same folder as the application, the ",(0,t.jsx)(o.code,{children:"assemblyFile"})," attribute is required. The attribute is used to map the ",(0,t.jsx)(o.code,{children:"moduleType"})," to the correct ",(0,t.jsx)(o.code,{children:"IModuleTypeLoader"})," to use."]}),"\n"]}),"\n",(0,t.jsxs)(o.p,{children:["In your application's ",(0,t.jsx)(o.code,{children:"App"})," class, you need to specify that the configuration file is the source for your ",(0,t.jsx)(o.code,{children:"ModuleCatalog"}),". To do this, override the ",(0,t.jsx)(o.code,{children:"CreateModuleCatalog"})," method and return an instance of the ",(0,t.jsx)(o.code,{children:"ConfigurationModuleCatalog"})," class."]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-cs",children:"protected override IModuleCatalog CreateModuleCatalog()\n{\n    return new ConfigurationModuleCatalog();\n}\n"})}),"\n",(0,t.jsxs)(o.blockquote,{children:["\n",(0,t.jsxs)(o.p,{children:[(0,t.jsx)(o.strong,{children:"Note:"})," You can still add modules to a ",(0,t.jsx)(o.code,{children:"ConfigurationModuleCatalog"})," in code. You can use this, for example, to make sure that the modules that your application absolutely needs to function are defined in the catalog."]}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"To specify dependencies in the app.config file:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-xml",children:'<-- app.config --\x3e\n<modules>\n    <module assemblyFile="ModuleE.dll" moduleType="ModuleE.Module, ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" moduleName="moduleE" />\n    <module assemblyFile="ModuleF.dll" moduleType="ModuleF.Module, ModuleF, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" moduleName="moduleF">\n        <dependencies>\n            <dependency moduleName="moduleE" />\n        </dependencies>\n    </module>\n</modules>\n'})}),"\n",(0,t.jsxs)(o.p,{children:["To specify on-demand loading using a configuration file, set the ",(0,t.jsx)(o.code,{children:"startupLoaded"})," attribute of the ",(0,t.jsx)(o.code,{children:"module"})," element to ",(0,t.jsx)(o.code,{children:"false"}),"."]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-xml",children:'<module assemblyFile="ModularityWithUnity.Desktop.ModuleE.dll" moduleType="ModularityWithUnity.Desktop.ModuleE, ModularityWithUnity.Desktop.ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" moduleName="ModuleE" startupLoaded="false" />\n'})}),"\n",(0,t.jsx)(o.h4,{id:"discovering-modules-in-a-directory",children:"Discovering Modules in a Directory"}),"\n",(0,t.jsxs)(o.p,{children:["The Prism ",(0,t.jsx)(o.code,{children:"DirectoryModuleCatalog"})," class allows you to specify a local directory as a module catalog in WPF. This module catalog will scan the specified folder and search for assemblies that define the modules for your application. To use this approach, you will need to use declarative attributes on your module classes to specify the module name and any dependencies that they have. The following code example shows a module catalog that is populated by discovering assemblies in a directory."]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-cs",children:'protected override IModuleCatalog CreateModuleCatalog()\n{\n    return new DirectoryModuleCatalog() {ModulePath = @".\\\\Modules"};\n}\n'})}),"\n",(0,t.jsx)(o.p,{children:"To specify dependencies, use the same method as if you were using code."}),"\n",(0,t.jsxs)(o.p,{children:["To handle loading on demand or at startup, update the ",(0,t.jsx)(o.code,{children:"Module"})," attribute as follows:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-cs",children:'[Module(ModuleName = "ModuleA", OnDemand = true)]\n[ModuleDependency("ModuleD")]\npublic class ModuleA : IModule\n{\n    ...\n}\n'})}),"\n",(0,t.jsx)(o.h2,{id:"other-modularity-items-of-note",children:"Other Modularity Items of Note"}),"\n",(0,t.jsx)(o.h3,{id:"requesting-on-demand-loading-of-module",children:"Requesting On-Demand loading of Module"}),"\n",(0,t.jsxs)(o.p,{children:["After a module is specified as on-demand, the application can ask the module to be loaded. The code that wants to initiate the loading needs to obtain a reference to the ",(0,t.jsx)(o.code,{children:"IModuleManager"})," service registered with the container in the ",(0,t.jsx)(o.code,{children:"App"})," class."]}),"\n",(0,t.jsx)(o.p,{children:"An explicit load of a module can be performed by the following code:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-cs",children:"public class SomeViewModel : BindableBase\n{\n    private IModuleManager _moduleManager = null;\n\n    public SomeViewModel(IModuleManager moduleManager)\n    {\n        // use dependency injection to get the module manager\n        _moduleManager = moduleManager;\n    }\n\n    private void LoadSomeModule(string moduleName)\n    {\n        _moduleManager.LoadModule(moduleName);\n    }\n}\n"})}),"\n",(0,t.jsx)(o.h3,{id:"detecting-when-a-module-is-loaded",children:"Detecting When a Module is Loaded"}),"\n",(0,t.jsxs)(o.p,{children:["The ",(0,t.jsx)(o.code,{children:"ModuleManager"})," service provides an event for applications to track when a module loads or fails to load."]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-cs",children:"public class SomeViewModel : BindableBase\n{\n    private IModuleManager _moduleManager = null;\n\n    public SomeViewModel(IModuleManager moduleManager)\n    {\n        _moduleManager = moduleManager;\n        _moduleManager.LoadModuleCompleted += _moduleManager_LoadModuleCompleted;\n    }\n\n    private void _moduleManager_LoadModuleCompleted(object sender, LoadModuleCompletedEventArgs e)\n    {\n        // ...\n    }\n}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["To keep the application and modules loosely coupled, the application should avoid using this event to integrate the module with the application. Instead, the module's ",(0,t.jsx)(o.code,{children:"RegisterTypes"})," and ",(0,t.jsx)(o.code,{children:"OnInitialized"})," should handle integrating with the application."]}),"\n",(0,t.jsxs)(o.p,{children:["The ",(0,t.jsx)(o.code,{children:"LoadModuleCompletedEventArgs"})," contains an ",(0,t.jsx)(o.code,{children:"IsErrorHandled"})," property. If a module fails to load and the application wants to prevent the ",(0,t.jsx)(o.code,{children:"ModuleManager"})," from logging the error and throwing an exception, it can set this property to ",(0,t.jsx)(o.strong,{children:"true"}),"."]}),"\n",(0,t.jsxs)(o.blockquote,{children:["\n",(0,t.jsxs)(o.p,{children:[(0,t.jsx)(o.strong,{children:"Note"}),": After a module is loaded and initialized, the module assembly cannot be unloaded. The module instance reference will not be held by the Prism libraries, so the module class instance may be garbage collected after initialization is complete."]}),"\n"]})]})}function u(e={}){const{wrapper:o}={...(0,l.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},6616:(e,o,n)=>{n.d(o,{A:()=>i});const i=n.p+"assets/images/ModularityAppArchitecture-f69cf02ec457649e646906fa4cf1f352.png"},8453:(e,o,n)=>{n.d(o,{R:()=>a,x:()=>s});var i=n(6540);const t={},l=i.createContext(t);function a(e){const o=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function s(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(l.Provider,{value:o},e.children)}}}]);