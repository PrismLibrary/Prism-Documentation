"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[352],{1640:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>d,metadata:()=>a,toc:()=>r});const a=JSON.parse('{"id":"commands/commanding","title":"Commanding","description":"In addition to providing access to the data to be displayed or edited in the view, the ViewModel will likely define one or more actions or operations that can be performed by the user. Actions or operations that the user can perform through the UI are typically defined as commands. Commands provide a convenient way to represent actions or operations that can be easily bound to controls in the UI. They encapsulate the actual code that implements the action or operation and help to keep it decoupled from its actual visual representation in the view.","source":"@site/docs/commands/commanding.md","sourceDirName":"commands","slug":"/commands/commanding","permalink":"/docs/current/commands/commanding","draft":false,"unlisted":false,"editUrl":"https://github.com/PrismLibrary/Prism-Documentation/edit/master/docs/commands/commanding.md","tags":[],"version":"current","lastUpdatedBy":"Dan Siegel","lastUpdatedAt":1763924282000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Prism","permalink":"/docs/current/"},"next":{"title":"Composite Commands","permalink":"/docs/current/commands/composite-commands"}}');var o=t(4848),i=t(8453);const d={sidebar_position:1},s="Commanding",c={},r=[{value:"Creating a DelegateCommand",id:"creating-a-delegatecommand",level:2},{value:"Invoking DelegateCommands from the View",id:"invoking-delegatecommands-from-the-view",level:2},{value:"Raising Change Notifications",id:"raising-change-notifications",level:2},{value:"RaiseCanExecuteChanged",id:"raisecanexecutechanged",level:3},{value:"ObservesProperty",id:"observesproperty",level:3},{value:"ObservesCanExecute",id:"observescanexecute",level:3},{value:"Implementing a Task-Based DelegateCommand",id:"implementing-a-task-based-delegatecommand",level:2}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"commanding",children:"Commanding"})}),"\n",(0,o.jsx)(n.p,{children:"In addition to providing access to the data to be displayed or edited in the view, the ViewModel will likely define one or more actions or operations that can be performed by the user. Actions or operations that the user can perform through the UI are typically defined as commands. Commands provide a convenient way to represent actions or operations that can be easily bound to controls in the UI. They encapsulate the actual code that implements the action or operation and help to keep it decoupled from its actual visual representation in the view."}),"\n",(0,o.jsx)(n.p,{children:"Commands can be visually represented and invoked in many different ways by the user as they interact with the view. In most cases, they are invoked as a result of a mouse click, but they can also be invoked as a result of shortcut key presses, touch gestures, or any other input events. Controls in the view are data bound to the ViewModels's commands so that the user can invoke them using whatever input event or gesture the control defines. Interaction between the UI controls in the view and the command can be two-way. In this case, the command can be invoked as the user interacts with the UI, and the UI can be automatically enabled or disabled as the underlying command becomes enabled or disabled."}),"\n",(0,o.jsxs)(n.p,{children:["The ViewModel can implement commands as a ",(0,o.jsx)(n.strong,{children:"Command Object"})," (an object that implements the ",(0,o.jsx)(n.code,{children:"ICommand"})," interface). The view's interaction with the command can be defined declaratively without requiring complex event handling code in the view's code-behind file. For example, certain controls inherently support commands and provide a ",(0,o.jsx)(n.code,{children:"Command"})," property that can be data bound to an ",(0,o.jsx)(n.code,{children:"ICommand"})," object provided by the ViewModel. In other cases, a command behavior can be used to associate a control with a command method or command object provided by the ViewModel."]}),"\n",(0,o.jsxs)(n.p,{children:["Implementing the ",(0,o.jsx)(n.code,{children:"ICommand"})," interface is straightforward. Prism provides the ",(0,o.jsx)(n.code,{children:"DelegateCommand"})," implementation of this interface that you can readily use in your applications."]}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"DelegateCommand"})," can be found in the Prism.Commands namespace which is located in the Prism.Core NuGet package."]})}),"\n",(0,o.jsx)(n.h2,{id:"creating-a-delegatecommand",children:"Creating a DelegateCommand"}),"\n",(0,o.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/tYItSPv58Bo",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),"\n",(0,o.jsxs)(n.p,{children:["The Prism ",(0,o.jsx)(n.code,{children:"DelegateCommand"})," class encapsulates two delegates that each reference a method implemented within your ViewModel class. It implements the ",(0,o.jsx)(n.code,{children:"ICommand"})," interface's ",(0,o.jsx)(n.code,{children:"Execute"})," and ",(0,o.jsx)(n.code,{children:"CanExecute"})," methods by invoking these delegates. You specify the delegates to your ViewModel methods in the ",(0,o.jsx)(n.code,{children:"DelegateCommand"})," class constructor. For example, the following code example shows how a ",(0,o.jsx)(n.code,{children:"DelegateCommand"})," instance, which represents a Submit command, is constructed by specifying delegates to the OnSubmit and CanSubmit ViewModel methods. The command is then exposed to the view via a read-only property that returns a reference to the ",(0,o.jsx)(n.code,{children:"DelegateCommand"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cs",children:"public class ArticleViewModel\n{\n    public DelegateCommand<object> SubmitCommand { get; private set; }\n\n    public ArticleViewModel()\n    {\n        SubmitCommand = new DelegateCommand<object>(Submit, CanSubmit);\n    }\n\n    void Submit(object parameter)\n    {\n        //implement logic\n    }\n\n    bool CanSubmit(object parameter)\n    {\n        return true;\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["When the Execute method is called on the ",(0,o.jsx)(n.code,{children:"DelegateCommand"})," object, it simply forwards the call to the method in your ViewModel class via the delegate that you specified in the constructor. Similarly, when the ",(0,o.jsx)(n.code,{children:"CanExecute"})," method is called, the corresponding method in your ViewModel class is called. The delegate to the ",(0,o.jsx)(n.code,{children:"CanExecute"})," method in the constructor is optional. If a delegate is not specified, ",(0,o.jsx)(n.code,{children:"DelegateCommand"})," will always return ",(0,o.jsx)(n.code,{children:"true"})," for ",(0,o.jsx)(n.code,{children:"CanExecute"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"DelegateCommand"})," class is a generic type. The type argument specifies the type of the command parameter passed to the ",(0,o.jsx)(n.code,{children:"Execute"})," and ",(0,o.jsx)(n.code,{children:"CanExecute"})," methods. In the preceding example, the command parameter is of type ",(0,o.jsx)(n.code,{children:"object"}),". A ",(0,o.jsx)(n.strong,{children:"non-generic"})," version of the ",(0,o.jsx)(n.code,{children:"DelegateCommand"})," class is also provided by Prism for use when a command parameter is not required, and is defined as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cs",children:"public class ArticleViewModel\n{\n    public DelegateCommand SubmitCommand { get; private set; }\n\n    public ArticleViewModel()\n    {\n        SubmitCommand = new DelegateCommand(Submit, CanSubmit);\n    }\n\n    void Submit()\n    {\n        //implement logic\n    }\n\n    bool CanSubmit()\n    {\n        return true;\n    }\n}\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"DelegateCommand"})," deliberately prevents the use of value types (int, double, bool, etc). Because ",(0,o.jsx)(n.code,{children:"ICommand"})," takes an ",(0,o.jsx)(n.code,{children:"object"}),", having a value type for ",(0,o.jsx)(n.code,{children:"T"})," would cause unexpected behavior when ",(0,o.jsx)(n.code,{children:"CanExecute(null)"})," is called during XAML initialization for command bindings. Using ",(0,o.jsx)(n.code,{children:"default(T)"})," was considered and rejected as a solution because the implementor would not be able to distinguish between a valid and defaulted values. If you wish to use a value type as a parameter, you must make it nullable by using ",(0,o.jsx)(n.code,{children:"DelegateCommand<Nullable<int>>"})," or the shorthand ",(0,o.jsx)(n.code,{children:"?"})," syntax (",(0,o.jsx)(n.code,{children:"DelegateCommand<int?>"}),")."]})}),"\n",(0,o.jsx)(n.h2,{id:"invoking-delegatecommands-from-the-view",children:"Invoking DelegateCommands from the View"}),"\n",(0,o.jsxs)(n.p,{children:["There are a number of ways in which a control in the view can be associated with a command object provided by the ViewModel. Certain WPF, .NET MAUI, and Uno Platform controls can be easily data bound to a command object through the ",(0,o.jsx)(n.code,{children:"Command"})," property."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<Button Command="{Binding SubmitCommand}" CommandParameter="OrderId"/>\n'})}),"\n",(0,o.jsxs)(n.p,{children:["A command parameter can also be optionally defined using the ",(0,o.jsx)(n.code,{children:"CommandParameter"})," property. The type of the expected argument is specified in the ",(0,o.jsx)(n.code,{children:"DelegateCommand<T>"})," generic declaration. The control will automatically invoke the target command when the user interacts with that control, and the command parameter, if provided, will be passed as the argument to the command's ",(0,o.jsx)(n.code,{children:"Execute"})," method. In the preceding example, the button will automatically invoke the ",(0,o.jsx)(n.code,{children:"SubmitCommand"})," when it is clicked. Additionally, if a ",(0,o.jsx)(n.code,{children:"CanExecute"})," delegate is specified, the button will be automatically disabled if ",(0,o.jsx)(n.code,{children:"CanExecute"})," returns ",(0,o.jsx)(n.code,{children:"false"}),", and it will be enabled if it returns ",(0,o.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"raising-change-notifications",children:"Raising Change Notifications"}),"\n",(0,o.jsxs)(n.p,{children:["The ViewModel often needs to indicate a change in the command's ",(0,o.jsx)(n.code,{children:"CanExecute"})," status so that any controls in the UI that are bound to the command will update their enabled status to reflect the availability of the bound command.  The ",(0,o.jsx)(n.code,{children:"DelegateCommand"})," provides several ways to send these notifications to the UI."]}),"\n",(0,o.jsx)(n.h3,{id:"raisecanexecutechanged",children:"RaiseCanExecuteChanged"}),"\n",(0,o.jsxs)(n.p,{children:["Use the ",(0,o.jsx)(n.code,{children:"RaiseCanExecuteChanged"})," method whenever you need to manually update the state of the bound UI elements.  For example, when the ",(0,o.jsx)(n.code,{children:"IsEnabled"})," property values changes, we are calling ",(0,o.jsx)(n.code,{children:"RaiseCanExecuteChanged"})," in the setter of the property to notify the UI of state changes."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cs",children:"        private bool _isEnabled;\n        public bool IsEnabled\n        {\n            get { return _isEnabled; }\n            set\n            {\n                SetProperty(ref _isEnabled, value);\n                SubmitCommand.RaiseCanExecuteChanged();\n            }\n        }\n"})}),"\n",(0,o.jsx)(n.h3,{id:"observesproperty",children:"ObservesProperty"}),"\n",(0,o.jsxs)(n.p,{children:["In cases where the command should send notifications when a property value changes, you can use the ",(0,o.jsx)(n.code,{children:"ObservesProperty"})," method. When using the ",(0,o.jsx)(n.code,{children:"ObservesProperty"})," method, whenever the value of the supplied property changes, the ",(0,o.jsx)(n.code,{children:"DelegateCommand"})," will automatically call ",(0,o.jsx)(n.code,{children:"RaiseCanExecuteChanged"})," to notify the UI of state changes."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cs",children:"public class ArticleViewModel : BindableBase\n{\n    private bool _isEnabled;\n    public bool IsEnabled\n    {\n        get { return _isEnabled; }\n        set { SetProperty(ref _isEnabled, value); }\n    }\n\n    public DelegateCommand SubmitCommand { get; private set; }\n\n    public ArticleViewModel()\n    {\n        SubmitCommand = new DelegateCommand(Submit, CanSubmit).ObservesProperty(() => IsEnabled);\n    }\n\n    void Submit()\n    {\n        //implement logic\n    }\n\n    bool CanSubmit()\n    {\n        return IsEnabled;\n    }\n}\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["You can chain-register multiple properties for observation when using the ",(0,o.jsx)(n.code,{children:"ObservesProperty"})," method. Example: ",(0,o.jsx)(n.code,{children:"ObservesProperty(() => IsEnabled).ObservesProperty(() => CanSave)"}),"."]})}),"\n",(0,o.jsx)(n.h3,{id:"observescanexecute",children:"ObservesCanExecute"}),"\n",(0,o.jsxs)(n.p,{children:["If your ",(0,o.jsx)(n.code,{children:"CanExecute"})," is the result of a simple ",(0,o.jsx)(n.code,{children:"Boolean"})," property, you can eliminate the need to declare a ",(0,o.jsx)(n.code,{children:"CanExecute"})," delegate, and use the ",(0,o.jsx)(n.code,{children:"ObservesCanExecute"})," method instead. ",(0,o.jsx)(n.code,{children:"ObservesCanExecute"})," will not only send notifications to the UI when the registered property value changes but it will also use that same property as the actual ",(0,o.jsx)(n.code,{children:"CanExecute"})," delegate."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cs",children:"public class ArticleViewModel : BindableBase\n{\n    private bool _isEnabled;\n    public bool IsEnabled\n    {\n        get { return _isEnabled; }\n        set { SetProperty(ref _isEnabled, value); }\n    }\n\n    public DelegateCommand SubmitCommand { get; private set; }\n\n    public ArticleViewModel()\n    {\n        SubmitCommand = new DelegateCommand(Submit).ObservesCanExecute(() => IsEnabled);\n    }\n\n    void Submit()\n    {\n        //implement logic\n    }\n}\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:["Do not attempt to chain-register ",(0,o.jsx)(n.code,{children:"ObservesCanExecute"})," methods. Only one property can be observed for the ",(0,o.jsx)(n.code,{children:"CanExcute"})," delegate."]})}),"\n",(0,o.jsx)(n.h2,{id:"implementing-a-task-based-delegatecommand",children:"Implementing a Task-Based DelegateCommand"}),"\n",(0,o.jsxs)(n.p,{children:["In today's world of ",(0,o.jsx)(n.code,{children:"async"}),"/",(0,o.jsx)(n.code,{children:"await"}),", calling asynchronous methods inside of the ",(0,o.jsx)(n.code,{children:"Execute"})," delegate is a very common requirement. Everyone's first instinct is that they need an ",(0,o.jsx)(n.code,{children:"AsyncCommand"}),", but that assumption is wrong. ",(0,o.jsx)(n.code,{children:"ICommand"})," by nature is synchronous, and the ",(0,o.jsx)(n.code,{children:"Execute"})," and ",(0,o.jsx)(n.code,{children:"CanExecute"})," delegates should be considered events.  This means that ",(0,o.jsx)(n.code,{children:"async void"})," is a perfectly valid syntax to use for commands.  There are two approaches to using async methods with ",(0,o.jsx)(n.code,{children:"DelegateCommand"}),"."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Option 1:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cs",children:"public class ArticleViewModel\n{\n    public DelegateCommand SubmitCommand { get; private set; }\n\n    public ArticleViewModel()\n    {\n        SubmitCommand = new DelegateCommand(Submit);\n    }\n\n    async void Submit()\n    {\n        await SomeAsyncMethod();\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Option 2:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cs",children:"public class ArticleViewModel\n{\n    public DelegateCommand SubmitCommand { get; private set; }\n\n    public ArticleViewModel()\n    {\n        SubmitCommand = new DelegateCommand(async ()=> await Submit());\n    }\n\n    Task Submit()\n    {\n        return SomeAsyncMethod();\n    }\n}\n"})})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>s});var a=t(6540);const o={},i=a.createContext(o);function d(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);