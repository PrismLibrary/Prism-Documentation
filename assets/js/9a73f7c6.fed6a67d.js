"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[7249],{2431:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"dependency-injection/resolution-errors","title":"Handling Resolution Errors","description":"This feature was introduced in Prism 8 and does not apply if your app is targeting an earlier version","source":"@site/versioned_docs/version-9.0/dependency-injection/resolution-errors.md","sourceDirName":"dependency-injection","slug":"/dependency-injection/resolution-errors","permalink":"/docs/9.0/dependency-injection/resolution-errors","draft":false,"unlisted":false,"editUrl":"https://github.com/PrismLibrary/Prism-Documentation/edit/master/versioned_docs/version-9.0/dependency-injection/resolution-errors.md","tags":[],"version":"9.0","lastUpdatedBy":"Dan Siegel","lastUpdatedAt":1763924282000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5,"uid":"DependencyInjection.HandlingResolutionErrors"},"sidebar":"tutorialSidebar","previous":{"title":"Using IPlatformInitializer","permalink":"/docs/9.0/dependency-injection/platform-specific-services"},"next":{"title":"The ContainerLocator","permalink":"/docs/9.0/dependency-injection/container-locator"}}');var r=o(4848),i=o(8453);const s={sidebar_position:5,uid:"DependencyInjection.HandlingResolutionErrors"},a="Handling Resolution Errors",d={},l=[];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"handling-resolution-errors",children:"Handling Resolution Errors"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"This feature was introduced in Prism 8 and does not apply if your app is targeting an earlier version"})}),"\n",(0,r.jsxs)(n.p,{children:["Exceptions happen for a variety of reasons. Some common errors developers run into is a Service that was not registered or invalid XAML that generates an Exception when the View is resolved. The Prism Container Extensions now are very intentional about catching any underlying container exception and throwing a ",(0,r.jsx)(n.code,{children:"ContainerResolutionException"}),". The goal of the ContainerResolutionException is simple... shorten the dev loop by giving you the information you need to diagnose and fix problems in your code."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ContainerResolutionException"})," contains a number of constant messages like ",(0,r.jsx)(n.code,{children:"MissingRegistration"}),", ",(0,r.jsx)(n.code,{children:"CannotResolveAbstractType"}),", or ",(0,r.jsx)(n.code,{children:"CyclicalDependency"}),". In addition to those constants, it exposes properties for the ServiceName and/or ServiceType that was being resolved."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class ModuleA : IModule\n{\n    private IServiceIForgotToRegister IAmADunce { get; }\n\n    public ModuleA(IServiceIForgotToRegister iAmADummy)\n    {\n        IAmADunce = iAmADummy;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Looking at the above code snippet we can see that I have a service I'm injecting into ModuleA as a hard dependency. Unfortunately I forgot to register it. We can of course hook into the LoadModuleCompleted event in the ModuleManager so that we can see what happens when the modules get loaded like shown here:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"protected override void InitializeModules()\n{\n    var manager = Container.Resolve<IModuleManager>();\n    manager.LoadModuleCompleted += LoadModuleCompleted;\n    manager.Run();\n}\n\nprivate void LoadModuleCompleted(object sender, LoadModuleCompletedEventArgs e)\n{\n    LoadModuleCompleted(e.ModuleInfo, e.Error, e.IsErrorHandled);\n}\n\nprotected virtual void LoadModuleCompleted(IModuleInfo moduleInfo, Exception error, bool isHandled)\n{\n    if (error != null)\n    {\n        // Do Something\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, I'm going to see that the error is a ContainerResolutionException and that the ServiceType is ModuleA with no ServiceName. But that doesn't really give me quite enough information. Luckily the ",(0,r.jsx)(n.code,{children:"ContainerResolutionException"})," also has a ",(0,r.jsx)(n.code,{children:"GetErrors()"})," method on it that provides us the ability to see what the type is and what the error is:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'protected virtual void LoadModuleCompleted(IModuleInfo moduleInfo, Exception error, bool isHandled)\n{\n    if (error != null && error is ContainerResolutionException cre)\n    {\n        var errors = cre.GetErrors();\n        foreach((var type, var ex) in errors)\n        {\n            Console.WriteLine($"Error with: {type.FullName}");\n            Console.WriteLine($"{ex.GetType().Name}: {ex.Message}");\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"When we run this we should see something like the following output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Error with: MyProject.Services.IServiceIForgotToRegister\nContainerResolutionException: No Registration was found in the container for the specified type\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>a});var t=o(6540);const r={},i=t.createContext(r);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);