"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[9206],{6487:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>r,frontMatter:()=>s,metadata:()=>i,toc:()=>m});const i=JSON.parse('{"id":"commands/composite-commands","title":"Composite Commands","description":"In many cases, a command defined by a ViewModel will be bound to controls in the associated view so that the user can directly invoke the command from within the view. However, in some cases, you may want to be able to invoke commands on one or more ViewModels from a control in a parent view in the application\'s UI.","source":"@site/docs/commands/composite-commands.md","sourceDirName":"commands","slug":"/commands/composite-commands","permalink":"/docs/current/commands/composite-commands","draft":false,"unlisted":false,"editUrl":"https://github.com/PrismLibrary/Prism-Documentation/edit/master/docs/commands/composite-commands.md","tags":[],"version":"current","lastUpdatedBy":"Dan Siegel","lastUpdatedAt":1763924282000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"uid":"Commands.CompositeCommands"},"sidebar":"tutorialSidebar","previous":{"title":"Commanding","permalink":"/docs/current/commands/commanding"},"next":{"title":"Async Command\'s","permalink":"/docs/current/commands/async-commands"}}');var a=o(4848),t=o(8453);const s={sidebar_position:2,uid:"Commands.CompositeCommands"},c="Composite Commands",d={},m=[{value:"Creating a Composite Command",id:"creating-a-composite-command",level:2},{value:"Making a CompositeCommand Globally Available",id:"making-a-compositecommand-globally-available",level:2},{value:"Using Dependency Injection",id:"using-dependency-injection",level:3},{value:"Using a Static Class",id:"using-a-static-class",level:3},{value:"Binding to a Globally Available Command",id:"binding-to-a-globally-available-command",level:2},{value:"Using Dependency Injection",id:"using-dependency-injection-1",level:3},{value:"Using a Static Class",id:"using-a-static-class-1",level:3},{value:"Unregister a Command",id:"unregister-a-command",level:2},{value:"Executing Commands on Active Views",id:"executing-commands-on-active-views",level:2}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"composite-commands",children:"Composite Commands"})}),"\n",(0,a.jsx)(n.p,{children:"In many cases, a command defined by a ViewModel will be bound to controls in the associated view so that the user can directly invoke the command from within the view. However, in some cases, you may want to be able to invoke commands on one or more ViewModels from a control in a parent view in the application's UI."}),"\n",(0,a.jsx)(n.p,{children:"For example, if your application allows the user to edit multiple items at the same time, you may want to allow the user to save all the items using a single command represented by a button in the application's toolbar or ribbon. In this case, the Save All command will invoke each of the Save commands implemented by the ViewModel instance for each item as shown in the following illustration."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"SaveAll composite command",src:o(8353).A+"",width:"600",height:"297"})}),"\n",(0,a.jsxs)(n.p,{children:["Prism supports this scenario through the ",(0,a.jsx)(n.code,{children:"CompositeCommand"})," class."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"CompositeCommand"})," class represents a command that is composed from multiple child commands. When the composite command is invoked, each of its child commands is invoked in turn. It is useful in situations where you need to represent a group of commands as a single command in the UI or where you want to invoke multiple commands to implement a logical command."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"CompositeCommand"})," class maintains a list of child commands (",(0,a.jsx)(n.code,{children:"DelegateCommand"})," instances). The ",(0,a.jsx)(n.code,{children:"Execute"})," method of the ",(0,a.jsx)(n.code,{children:"CompositeCommand"})," class simply calls the ",(0,a.jsx)(n.code,{children:"Execute"})," method on each of the child commands in turn. The ",(0,a.jsx)(n.code,{children:"CanExecute"})," method similarly calls the ",(0,a.jsx)(n.code,{children:"CanExecute"})," method of each child command, but if any of the child commands cannot be executed, the ",(0,a.jsx)(n.code,{children:"CanExecute"})," method will return ",(0,a.jsx)(n.code,{children:"false"}),". In other words, by default, a ",(0,a.jsx)(n.code,{children:"CompositeCommand"})," can only be executed when all the child commands can be executed."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"CompositeCommand"})," can be found in the Prism.Commands namespace which is located in the Prism.Core NuGet package."]})}),"\n",(0,a.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/kssprOqdfME",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),"\n",(0,a.jsx)(n.h2,{id:"creating-a-composite-command",children:"Creating a Composite Command"}),"\n",(0,a.jsxs)(n.p,{children:["To create a composite command, instantiate a ",(0,a.jsx)(n.code,{children:"CompositeCommand"})," instance and then expose it as either an ",(0,a.jsx)(n.code,{children:"ICommand"})," or ",(0,a.jsx)(n.code,{children:"CompositeCommand"})," property."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"    public class ApplicationCommands\n    {\n        private CompositeCommand _saveCommand = new CompositeCommand();\n        public CompositeCommand SaveCommand\n        {\n            get => _saveCommand;\n        }\n    }\n"})}),"\n",(0,a.jsx)(n.h2,{id:"making-a-compositecommand-globally-available",children:"Making a CompositeCommand Globally Available"}),"\n",(0,a.jsxs)(n.p,{children:["Typically, CompositeCommands are shared throughout an application and need to be made available globally. It's important that when you register a child command with a ",(0,a.jsx)(n.code,{children:"CompositeCommand"})," that you are using the same instance of the CompositeCommand throughout the application. This requires the CompositeCommand to be defined as a singleton in your application.  This can be done by either using dependency injection (DI), or by defining your CompositeCommand as a static class."]}),"\n",(0,a.jsx)(n.h3,{id:"using-dependency-injection",children:"Using Dependency Injection"}),"\n",(0,a.jsx)(n.p,{children:"The first step in defining your CompositeCommands is to create an interface."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"    public interface IApplicationCommands\n    {\n        CompositeCommand SaveCommand { get; }\n    }\n"})}),"\n",(0,a.jsx)(n.p,{children:"Next, create a class that implements the interface."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"    public class ApplicationCommands : IApplicationCommands\n    {\n        private CompositeCommand _saveCommand = new CompositeCommand();\n        public CompositeCommand SaveCommand\n        {\n            get =>_saveCommand;\n        }\n    }\n"})}),"\n",(0,a.jsx)(n.p,{children:"Once you have defined your ApplicationCommands class, you must register it as a singleton with the container."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"    public partial class App : PrismApplication\n    {\n        protected override void RegisterTypes(IContainerRegistry containerRegistry)\n        {\n            containerRegistry.RegisterSingleton<IApplicationCommands, ApplicationCommands>();\n        }\n    }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Next, ask for the ",(0,a.jsx)(n.code,{children:"IApplicationCommands"})," interface in the ViewModel constructor.  Once you have an instance of the ",(0,a.jsx)(n.code,{children:"ApplicationCommands"})," class, can now register your DelegateCommands with the appropriate CompositeCommand."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"    public DelegateCommand UpdateCommand { get; private set; }\n\n    public TabViewModel(IApplicationCommands applicationCommands)\n    {\n        UpdateCommand = new DelegateCommand(Update);\n        applicationCommands.SaveCommand.RegisterCommand(UpdateCommand);\n    }\n"})}),"\n",(0,a.jsx)(n.h3,{id:"using-a-static-class",children:"Using a Static Class"}),"\n",(0,a.jsx)(n.p,{children:"Create a static class that will represent your CompositeCommands"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"public static class ApplicationCommands\n{\n    public static CompositeCommand SaveCommand = new CompositeCommand();\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In your ViewModel, associate child commands to the static ",(0,a.jsx)(n.code,{children:"ApplicationCommands"})," class."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"    public DelegateCommand UpdateCommand { get; private set; }\n\n    public TabViewModel()\n    {\n        UpdateCommand = new DelegateCommand(Update);\n        ApplicationCommands.SaveCommand.RegisterCommand(UpdateCommand);\n    }\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"To increase the maintainability and testability of your code, it is recommended that you using the dependency injection approach."})}),"\n",(0,a.jsx)(n.h2,{id:"binding-to-a-globally-available-command",children:"Binding to a Globally Available Command"}),"\n",(0,a.jsx)(n.p,{children:"Once you have created your CompositeCommands, you must now bind them to UI elements in order to invoke the commands."}),"\n",(0,a.jsx)(n.h3,{id:"using-dependency-injection-1",children:"Using Dependency Injection"}),"\n",(0,a.jsxs)(n.p,{children:["When using DI, you must expose the ",(0,a.jsx)(n.code,{children:"IApplicationCommands"})," for binding to a View.  In the ViewModel of the view, ask for the ",(0,a.jsx)(n.code,{children:"IApplicationCommands"})," in the constructor and set a property of type ",(0,a.jsx)(n.code,{children:"IApplicationCommands"})," to the instance."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"    public class MainWindowViewModel : BindableBase\n    {\n        private IApplicationCommands _applicationCommands;\n        public IApplicationCommands ApplicationCommands\n        {\n            get => _applicationCommands;\n            set => SetProperty(ref _applicationCommands, value);\n        }\n\n        public MainWindowViewModel(IApplicationCommands applicationCommands)\n        {\n            ApplicationCommands = applicationCommands;\n        }\n    }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In the view, bind the button to the ",(0,a.jsx)(n.code,{children:"ApplicationCommands.SaveCommand"})," property. The ",(0,a.jsx)(n.code,{children:"SaveCommand"})," is a property that is defined on the ",(0,a.jsx)(n.code,{children:"ApplicationCommands"})," class."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<Button Content="Save" Command="{Binding ApplicationCommands.SaveCommand}"/>\n'})}),"\n",(0,a.jsx)(n.h3,{id:"using-a-static-class-1",children:"Using a Static Class"}),"\n",(0,a.jsx)(n.p,{children:"If you are using the static class approach, the following code example shows how to bind a button to the static ApplicationCommands class in WPF."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<Button Content="Save" Command="{x:Static local:ApplicationCommands.SaveCommand}" />\n'})}),"\n",(0,a.jsx)(n.h2,{id:"unregister-a-command",children:"Unregister a Command"}),"\n",(0,a.jsxs)(n.p,{children:["As seen in the previous examples, child commands are registered using the ",(0,a.jsx)(n.code,{children:"CompositeCommand.RegisterCommand"})," method. However, when you no longer wish to respond to a CompositeCommand or if you are destroying the View/ViewModel for garbage collection, you should unregister the child commands with the ",(0,a.jsx)(n.code,{children:"CompositeCommand.UnregisterCommand"})," method."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"    public void Destroy()\n    {\n        _applicationCommands.UnregisterCommand(UpdateCommand);\n    }\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["You MUST unregister your commands from a ",(0,a.jsx)(n.code,{children:"CompositeCommand"})," when the View/ViewModel is no longer needed (ready for GC). Otherwise you will have introduced a memory leak."]})}),"\n",(0,a.jsx)(n.h2,{id:"executing-commands-on-active-views",children:"Executing Commands on Active Views"}),"\n",(0,a.jsx)(n.p,{children:"Composite commands at the parent view level will often be used to coordinate how commands at the child view level are invoked. In some cases, you will want the commands for all shown views to be executed, as in the Save All command example described earlier. In other cases, you will want the command to be executed only on the active view. In this case, the composite command will execute the child commands only on views that are deemed to be active; it will not execute the child commands on views that are not active. For example, you may want to implement a Zoom command on the application's toolbar that causes only the currently active item to be zoomed, as shown in the following diagram."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Executing a CompositeCommand on a single child",src:o(8458).A+"",width:"600",height:"297"})}),"\n",(0,a.jsxs)(n.p,{children:["To support this scenario, Prism provides the ",(0,a.jsx)(n.code,{children:"IActiveAware"})," interface. The ",(0,a.jsx)(n.code,{children:"IActiveAware"})," interface defines an ",(0,a.jsx)(n.code,{children:"IsActive"})," property that returns ",(0,a.jsx)(n.code,{children:"true"})," when the implementer is active, and an ",(0,a.jsx)(n.code,{children:"IsActiveChanged"})," event that is raised whenever the active state is changed."]}),"\n",(0,a.jsxs)(n.p,{children:["You can implement the ",(0,a.jsx)(n.code,{children:"IActiveAware"})," interface on views or ViewModels. It is primarily used to track the active state of a view. Whether or not a view is active is determined by the views within the specific control. For the Tab control, there is an adapter that sets the view in the currently selected tab as active, for example."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"DelegateCommand"})," class also implements the ",(0,a.jsx)(n.code,{children:"IActiveAware"})," interface. The ",(0,a.jsx)(n.code,{children:"CompositeCommand"})," can be configured to evaluate the active status of child DelegateCommands (in addition to the ",(0,a.jsx)(n.code,{children:"CanExecute"})," status) by specifying ",(0,a.jsx)(n.code,{children:"true"})," for the ",(0,a.jsx)(n.code,{children:"monitorCommandActivity"})," parameter in the constructor. When this parameter is set to ",(0,a.jsx)(n.code,{children:"true"}),", the ",(0,a.jsx)(n.code,{children:"CompositeCommand"})," class will consider each child DelegateCommand's active status when determining the return value for the ",(0,a.jsx)(n.code,{children:"CanExecute"})," method and when executing child commands within the ",(0,a.jsx)(n.code,{children:"Execute"})," method."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"    public class ApplicationCommands : IApplicationCommands\n    {\n        private CompositeCommand _saveCommand = new CompositeCommand(true);\n        public CompositeCommand SaveCommand\n        {\n            get => _saveCommand;\n        }\n    }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When the ",(0,a.jsx)(n.code,{children:"monitorCommandActivity"})," parameter is ",(0,a.jsx)(n.code,{children:"true"}),", the ",(0,a.jsx)(n.code,{children:"CompositeCommand"})," class exhibits the following behavior:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"CanExecute"}),": Returns ",(0,a.jsx)(n.code,{children:"true"})," only when all active commands can be executed. Child commands that are inactive will not be considered at all."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Execute"}),": Executes all active commands. Child commands that are inactive will not be considered at all."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["By implementing the ",(0,a.jsx)(n.code,{children:"IActiveAware"})," interface on your ViewModels, you will be notified when your view becomes active or inactive. When the view's active status changes, you can update the active status of the child commands. Then, when the user invokes the composite command, the command on the active child view will be invoked."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"    public class TabViewModel : BindableBase, IActiveAware\n    {\n        private bool _isActive;\n        public bool IsActive\n        {\n            get { return _isActive; }\n            set => SetProperty(ref _isActive, OnIsActiveChanged);\n        }\n\n        public event EventHandler IsActiveChanged;\n\n        public DelegateCommand UpdateCommand { get; private set; }\n\n        public TabViewModel(IApplicationCommands applicationCommands)\n        {\n            UpdateCommand = new DelegateCommand(Update);\n            applicationCommands.SaveCommand.RegisterCommand(UpdateCommand);\n        }\n\n        private void Update()\n        {\n            //implement logic\n        }\n\n        private void OnIsActiveChanged()\n        {\n            UpdateCommand.IsActive = IsActive; //set the command as active\n            IsActiveChanged?.Invoke(this, new EventArgs()); //invoke the event for all listeners\n        }\n    }\n"})})]})}function r(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8353:(e,n,o)=>{o.d(n,{A:()=>i});const i=o.p+"assets/images/composite-commands-1-e181db1e45bd206952368ec70fe579f0.png"},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>c});var i=o(6540);const a={},t=i.createContext(a);function s(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(t.Provider,{value:n},e.children)}},8458:(e,n,o)=>{o.d(n,{A:()=>i});const i=o.p+"assets/images/composite-commands-2-cbabac2a125bd4c700e0b30164f628c6.png"}}]);